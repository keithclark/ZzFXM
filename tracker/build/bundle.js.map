{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../src/config.js","../../node_modules/svelte/store/index.mjs","../../src/stores.js","../../../local_modules/zzfxm-song-encoder/encode.js","../../../local_modules/zzfxm-song-encoder/validate.js","../../../local_modules/zzfxm-song-encoder/decode.js","../../src/services/InstrumentService.js","../../src/lib/utils.js","../../src/services/PatternService.js","../../src/services/SequenceService.js","../../src/services/SongService.js","../../src/services/RendererService1.js","../../src/components/Field.svelte","../../src/components/Button.svelte","../../src/components/PlayButton.svelte","../../src/components/SequenceEditor.svelte","../../src/components/ToggleButton.svelte","../../src/services/DomService.js","../../src/components/Icon.svelte","../../src/components/WarningIndicator.svelte","../../src/components/Property.svelte","../../src/components/TextProperty.svelte","../../src/components/NumberProperty.svelte","../../src/components/SampleViewer.svelte","../../../local_modules/zzfxm-instruments/percussion.js","../../../local_modules/zzfxm-instruments/keyboards.js","../../../local_modules/zzfxm-instruments/wind.js","../../src/components/InstrumentPicker.svelte","../../node_modules/svelte/easing/index.mjs","../../node_modules/svelte/transition/index.mjs","../../src/components/Modal.svelte","../../src/components/InstrumentEditor.svelte","../../src/components/Slider.svelte","../../src/components/PanningProperty.svelte","../../src/components/Channel.svelte","../../src/components/PianoInput.svelte","../../src/components/PatternEditor.svelte","../../src/components/KeyboardHelp.svelte","../../src/components/About.svelte","../../src/components/SourceEditor.svelte","../../src/components/PropertyList.svelte","../../src/components/EnumProperty.svelte","../../src/components/Preferences.svelte","../../src/components/SongProperties.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.1' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","// The number of pattern rows to jump when using fine navigation\nexport const PATTERN_ROW_FINE_STEP = 1;\n\n// The number of pattern rows to jump when using coarse navigation\nexport const PATTERN_ROW_COARSE_STEP = 4;\n\n// The number of attenutation steps to jump when using fine navigation\nexport const ATTENUATION_FINE_STEP = .01;\n\n// The number of attenutation steps to jump when using coarse navigation\nexport const ATTENUATION_COARSE_STEP = .1;\n\n// Keyboard map for notes\nexport const NOTE_KEY_CODES = {\n  'z': 1, 's': 2, 'x': 3, 'd': 4, 'c': 5, 'v': 6, 'g': 7, 'b': 8, 'h': 9,\n  'n': 10, 'j': 11, 'm': 12, ',': 13, 'l': 14, '.': 15, ';': 16, '/': 17,\n  'q': 18, '2': 19, 'w': 20, '3': 21, 'e': 22, '4': 23, 'r': 24, 't': 25,\n  '6': 26, 'y': 27, '7': 28, 'u': 29, 'i': 30, '9': 31, 'o': 32, '0': 33,\n  'p': 34, '-': 35, '[': 36\n};\n\n// UI update speed options - shown in the settings modal\nexport const UI_FPS_OPTIONS = [\n  60, 30, 15, 10, 5\n];\n\n// Sample rate options - shown in the settings modal\nexport const PLAYER_SAMPLE_RATE_OPTIONS = [\n  44100, 22050, 11025\n];\n\n// Song player buffer size options\nexport const PLAYER_BUFFER_SIZE_OPTIONS = [\n  16384, 8192, 4096, 2048, 1024\n];\n\n// The default sample rate for the song player\nexport const DEFAULT_PLAYER_SAMPLE_RATE = PLAYER_SAMPLE_RATE_OPTIONS[0];\n\n// The default buffer size for the song player\nexport const DEFAULT_PLAYER_BUFFER_SIZE = PLAYER_BUFFER_SIZE_OPTIONS[2];\n\n// The default UI refresh rate\nexport const DEFAULT_UI_FPS = UI_FPS_OPTIONS[0];\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import {\n    DEFAULT_PLAYER_BUFFER_SIZE,\n    DEFAULT_PLAYER_SAMPLE_RATE,\n    DEFAULT_UI_FPS\n} from './config.js';\n\nimport { writable } from 'svelte/store';\n\n\n// Song\nexport const title = new writable('');\nexport const speed = new writable(125);\nexport const instruments = new writable([]);\nexport const instrumentsMeta = new writable([]);\nexport const patterns = new writable([]);\nexport const patternsMeta = new writable([]);\nexport const sequence = new writable([]);\nexport const meta = new writable({});\n\n\n// Selections\nexport const selectedRow = new writable();\nexport const selectedChannel = new writable(0);\nexport const selectedPattern = new writable(0);\nexport const selectedSequence = new writable(0);\nexport const selectedInstrument = new writable(0);\n\n\n// Audio\nexport const masterVolume = new writable(.5);\nexport const currentPlaybackPosition = new writable(0);\nexport const currentPlaybackLength = new writable(0);\nexport const channelMeters = new writable([]);\nexport const patternMuteStates = new writable([]);\nexport const songPlaying = new writable(false);\n\n\n// Settings\nexport const sampleRate = new writable(DEFAULT_PLAYER_SAMPLE_RATE);\nexport const bufferSize = new writable(DEFAULT_PLAYER_BUFFER_SIZE);\nexport const uiFPS = new writable(DEFAULT_UI_FPS);\n","/**\n * Encode a number into the smallest possible footprint. Removes leading 0 from\n * decimal numbers and replaces three or more trailing 0's with `e` notation.\n *\n * @param {Number} value\n * @returns {String} the encoded value\n */\nexport const encodeNumber = value => {\n  let encoded = JSON.stringify(value);\n  encoded = encoded.replace(/^(-?)0/g, '$1');\n  encoded = encoded.replace(/0{3,}$/g, m => `e${m.length}`);\n  return encoded;\n}\n\n\n/**\n * Encodes ZzFX instruments into a string, removing values as needed to keep\n * size to a minimum.\n *\n * @param {Array.<Number[]>} instruments\n */\nexport const encodeInstruments = instruments => {\n  return `[${instruments.map(encodeInstrument).join(',')}]`;\n}\n\n/**\n * Encodes ZzFX instrument into a string, removing values as needed to keep\n * size to a minimum.\n *\n * @param {Array.<Number[]>} instrument\n */\nexport const encodeInstrument = instrument => {\n\n  let params = instrument.map((v,i) => {\n    let encoded = encodeNumber(v);\n\n    // Volume\n    if (i == 0) {\n      if (encoded == '1') {\n        encoded = '';\n      } else if (encoded == '') {\n        encoded = '0';\n      }\n    }\n\n    // Randomness\n    else if (i == 1) {\n      if (encoded == '.05') {\n        encoded = '';\n      } else if (encoded == '') {\n        encoded = '0';\n      }\n    }\n\n    // Frequency\n    else if (i == 2) {\n      if (encoded == '220') {\n        encoded = '';\n      } else if (encoded == '') {\n        encoded = '0';\n      }\n    }\n\n    // Release\n    else if (i == 5) {\n      if (encoded == '.1') {\n        encoded = '';\n      } else if (encoded == '') {\n        encoded = '0';\n      }\n    }\n\n    // Shape Curve\n    else if (i == 7) {\n      if (encoded == '1') {\n        encoded = '';\n      } else if (encoded == '') {\n        encoded = '0';\n      }\n    }\n\n    // Sustain Volume\n    else if (i == 17) {\n      if (encoded == '1') {\n        encoded = '';\n      } else if (encoded == '') {\n        encoded = '0';\n      }\n    }\n\n    else if (encoded === '0' || encoded === 'null') {\n      encoded = ''\n    }\n    return encoded;\n  });\n\n\n  // We must always return an instrument or the player will choke.\n  if (params.length === 0) {\n    params = [,0]\n  }\n\n  return `[${params.join(',').replace(/,+$/g, '')}]`;\n}\n\n\n/**\n * Encodes song patterns into a string, removing values as needed to keep\n * size to a minimum.\n *\n * @param {Array>} patterns The song pattern list\n */\nexport const encodePatterns = patterns => {\n  return JSON.stringify(patterns)\n    .replace(/null/g, '')\n    .replace(/(\\D)0(?=\\D)/g, '$1')\n    .replace(/,]/g, ',,]')\n\n}\n\n\n/**\n * Encodes song sequence into a string.\n *\n * @param {Array.<Number>} sequence The song sequence\n */\nexport const encodeSequence = sequence => {\n  return JSON.stringify(sequence);\n}\n\n\n/**\n * Encodes song metadata into a string.\n *\n * @param {Object} metadata The song meta data\n */\nexport const encodeMetadata = metaData => {\n  return JSON.stringify(metaData);\n}\n\n\n/**\n * Encodes song speed value into a string.\n *\n * @param {Object} panning The song panning data\n */\nexport const encodeSpeed = speed => {\n  if (speed !== 125) {\n    return JSON.stringify(speed);\n  }\n}\n\n/**\n * Encodes song data into a string, removing values as needed to keep size to a\n * minimum.\n *\n * @param {*} song The song to encode\n */\nexport const encodeSong = song => {\n  let elements = [\n    encodeInstruments(song[0]),\n    encodePatterns(song[1]),\n    encodeSequence(song[2]),\n    encodeSpeed(song[3]),\n    encodeMetadata(song[4])\n  ];\n  return `[${elements.join(',').replace(/,+$/, '')}]`\n}\n\n","const notNumber = v => !isNumber(v);\n\nconst notArray = v => !isArray(v);\n\nconst notObject = v => !isObject(v);\n\nconst isNumber = v => notObject(v) && !isNaN(parseFloat(v));\n\nconst isArray = v => Array.isArray(v);\n\nconst isObject = v => v !== null && v !== undefined && Object.is(v.constructor, Object);\n\n/**\n * Check a value is a valid song sequence\n *\n * @param {*} sequence - The value to check\n * @returns {true|Error} - `true` if valid, otherwise an `Error`\n */\nconst validateSequence = sequence => {\n  if (notArray(sequence)) {\n    return new Error('Missing sequence structure');\n  }\n  sequence = [...sequence];\n  if (sequence.some(notNumber)) {\n    return new Error('Invalid sequence parameter type');\n  }\n  return true;\n}\n\n\n/**\n * Check a value is a valid song patterns object\n *\n * @param {*} patterns - The value to check\n * @returns {true|Error} - `true` if valid, otherwise an `Error`\n */\nconst validatePatterns = patterns => {\n  if (notArray(patterns)) {\n    return new Error('Missing pattern structure');\n  }\n  patterns = [...patterns];\n  if (patterns.some(notArray)) {\n    return new Error('Invalid pattern structure');\n  }\n  if (patterns.flat(2).some(notNumber)) {\n    return new Error('Invalid pattern parameter type');\n  }\n  return true;\n}\n\n\n/**\n * Check a value is a valid song instruments object\n *\n * @param {*} instruments - The value to check\n * @returns {true|Error} - `true` if valid, otherwise an `Error`\n */\nconst validateInstruments = instruments => {\n  if (notArray(instruments)) {\n    return new Error('Missing instrument structure');\n  }\n  instruments = [...instruments];\n  if (instruments.some(notArray)) {\n    return new Error('Invalid instrument structure');\n  }\n  if (instruments.flat().some(notNumber)) {\n    return new Error('Invalid instrument parameter type');\n  }\n  return true;\n}\n\n\n/**\n * Check a value is a valid song object\n *\n * @param {*} song - The value to check\n * @returns {true|Error} - `true` if valid, otherwise an `Error`\n */\n\nexport const validateSong = song => {\n\n  let valid;\n\n  if (!Array.isArray(song)) {\n    return new Error('Invalid song syntax');\n  }\n\n  valid = validateInstruments(song[0]);\n  if (valid instanceof Error) {\n    return valid;\n  }\n\n  valid = validatePatterns(song[1]);\n  if (valid instanceof Error) {\n    return valid;\n  }\n\n  valid = validateSequence(song[2]);\n  if (valid instanceof Error) {\n    return valid;\n  }\n\n  // Element 3 should be a number (or undefined)\n  if (song[3] !== undefined && notNumber(song[3])) {\n    return new Error('Invalid speed');\n  }\n\n  // Element 4 should be a object (or undefined)\n  if (song[4] !== undefined && notObject(song[4])) {\n    return new Error('Invalid meta data');\n  }\n\n  return true;\n};\n","import { validateSong } from './validate.js';\n\n\n/**\n * Parse a short-json string into an object.\n *\n * @param {string} str - the string to parse\n */\nconst parse = str => {\n  return JSON.parse(jsonSafe(str), (key, value) => {\n    if (value === null) {\n      return undefined;\n    }\n    return value;\n  });\n};\n\n\n/**\n * Converts a serialised JS object into JSON compatiable format\n * @param {*} str - the string to convert\n */\nconst jsonSafe = str => {\n  return str.replace(/\\[,/g,'[null,')\n    .replace(/,,\\]/g,',null]') // remove `undefined` work around\n    .replace(/,\\s*(?=[,\\]])/g,',null')\n    .replace(/([\\[,]-?)(?=\\.)/g,'$10')\n    .replace(/-\\./g,'-0.');\n};\n\n\n/**\n * Decodes song pattern array, restoring default values\n *\n * @param {Array.<Number>} Pattern paramaters\n */\nexport const decodePatternParams = pattern => {\n  return pattern.map(channel => {\n    return [...channel].map(data => data || 0)\n  });\n};\n\n\n/**\n * Decodes ZzFX instrument array, restoring default values\n *\n * @param {Array.<Number>} ZzFX paramaters for the instrument\n */\nexport const decodeInstrumentParams = instrument => {\n  const params = instrument.slice();\n  params.length = 24;\n\n  return [...params].map((param, index) => {\n    if (index === 0 && param === undefined) {\n      return 1;\n    }\n    if (index === 1 && param === undefined) {\n      return 0.05;\n    }\n    if (index === 2 && param === undefined) {\n      return 220;\n    }\n    if (index === 5 && param === undefined) {\n      return .1;\n    }\n    if (index === 7 && param === undefined) {\n      return 1;\n    }\n    if (index === 17 && param === undefined) {\n      return 1;\n    }\n    return param || 0;\n  });\n};\n\n\n/**\n * Decodes a string representation of an instrument into an array of\n * zzfx parameters\n *\n * @param {string} instrument The instrument to decode\n * @returns {Array.<Number>} ZzFX paramaters for the instrument\n */\nexport const decodeInstrument = instrument => {\n  return decodeInstrumentParams(parse(instrument))\n};\n\n\n/**\n * Decodes a string representation of a song into an array\n *\n * @param {string} song The song to decode\n */\nexport const decodeSong = song => {\n  let data;\n\n  try {\n    data = parse(song);\n  } catch (e) {\n    throw new Error('Invalid file format');\n  }\n\n  const valid = validateSong(data);\n\n  if (valid instanceof Error) {\n    throw valid;\n  }\n\n  data[0] = data[0].map(decodeInstrumentParams);\n  data[1] = data[1].map(decodePatternParams);\n\n  return data;\n};\n","import { instruments, instrumentsMeta, patterns } from '../stores.js';\nimport { decodeInstrumentParams } from 'zzfxm-song-encoder';\n\nlet instrumentNo = 0;\n\n/**\n * Add a new instrument to the current song\n *\n * @param {Array} params - ZzFX instrument parameters of the new instrument\n * @param {string} name - Name of the new instrument\n * @returns {number} Index of the new instrument\n */\nexport const addInstrument = (params, name = `Instrument ${instrumentNo}`) => {\n  let newIndex;\n  instruments.update(instruments => {\n    instruments.push(createInstrument(...params));\n    newIndex = instruments.length - 1;\n    return instruments;\n  });\n  instrumentsMeta.update(meta => {\n    meta.push(name);\n    return meta;\n  });\n  instrumentNo++;\n  return newIndex;\n};\n\n\n/**\n * Delete an instrument from the current song. Reassigns instruments in the song\n * patterns to account for the missing index.\n *\n * @param {number} index - Index of the instrument to remove\n */\nexport const deleteInstrument = index => {\n  instruments.update(instruments => {\n    instruments.splice(index, 1);\n    return instruments;\n  });\n  instrumentsMeta.update(meta => {\n    meta.splice(index, 1);\n    return meta;\n  });\n  patterns.update(patterns => {\n    patterns.forEach(pattern => {\n      pattern.forEach(channel => {\n        if (channel[0] > index) {\n          channel[0]--;\n        }\n      });\n    });\n    return patterns;\n  });\n  instrumentNo++;\n};\n\n\n/**\n * Sets the ZzFX parameters of an existing instrument.\n *\n * @param {*} index - Index of the instrument to update\n * @param {Array} params - ZzFX instrument parameters of the new instrument\n */\nexport const setInstrumentParams = (index, params) => {\n  instruments.update(instruments => {\n    instruments[index] = createInstrument(...params);\n    return instruments;\n  });\n};\n\n\n/**\n * Clears all instrument data from the current song;\n */\nexport const clearInstruments = () => {\n  instrumentNo = 0;\n  instruments.set([]);\n  instrumentsMeta.set([]);\n};\n\n\n/**\n * Create a new instrument\n *\n * @param  {...number} ZzFX paramaters\n */\nexport const createInstrument = (...params) => {\n  return decodeInstrumentParams(params);\n};\n","/**\n * Ensure a number is between a given range\n *\n * @param {number} value - The value to clamp\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n */\nexport const clamp = (value, min, max) => {\n  return Math.max(min, Math.min(value, max));\n};\n\n\n/**\n * Rounds a number to a number of decimal places\n *\n * @param {number} value - The number to round\n * @param {number} decimalPlaces - Number of decimal places to round to\n */\nexport const round = (value, decimalPlaces = 2) => {\n  const pow = Math.pow(10, decimalPlaces);\n  return Math.round(value * pow) / pow;\n};\n\n\n/**\n * Determines if a HMTLElement is an input element\n *\n * @param {HTMLElement} element - The element to test.\n */\nexport const isInputElement = element => {\n  return 'form' in element;\n};\n\n\n/**\n * Performs a deep clone of an object.\n *\n * @param {object} obj - The object to clone\n */\nexport const deepClone = obj => {\n  return JSON.parse(JSON.stringify(obj));\n};\n\n\n/**\n * Returns a copy of an object with empty string properties removed\n */\nexport const removeEmptyStringValues = obj => {\n  const filtered = Object.entries(obj).filter(([key, value]) => value !== '');\n  return Object.fromEntries(filtered);\n};\n","import { patterns, patternsMeta, patternMuteStates, sequence } from '../stores.js';\nimport { clamp, round } from '../lib/utils.js';\n\nconst NOTE_NAMES = [\n  'REL', '---',\n  'C-1', 'C#1', 'D-1', 'D#1', 'E-1', 'F-1',\n  'F#1', 'G-1', 'G#1', 'A-1', 'A#1', 'B-1',\n  'C-2', 'C#2', 'D-2', 'D#2', 'E-2', 'F-2',\n  'F#2', 'G-2', 'G#2', 'A-2', 'A#2', 'B-2',\n  'C-3', 'C#3', 'D-3', 'D#3', 'E-3', 'F-3',\n  'F#3', 'G-3', 'G#3', 'A-3', 'A#3', 'B-3'\n];\n\n// This is used to auto-name patterns\nlet patternNo = 0;\n\n\n/**\n * Add a pattern to the current song\n *\n * @param {Array.<Channel>} pattern - New pattern data\n * @param {string} name - New pattern name\n * @returns {number} The new instruments index\n */\n// TODO: refactor to use setPattern?\nexport const addPattern = (pattern, name = `Pattern ${patternNo}`) => {\n  let newIndex;\n  patterns.update(patterns => {\n    patterns.push(pattern);\n    newIndex = patterns.length - 1;\n    return patterns;\n  });\n  patternsMeta.update(meta => {\n    meta.push(name);\n    return meta;\n  });\n  patternMuteStates.update(states => {\n    states.push(new Array(pattern.length).fill(false));\n    return states;\n  });\n  patternNo++;\n  return newIndex;\n};\n\n\n/**\n * Delete a pattern from the current song. Reassigns pattern indexes in the\n * song sequence to account for the missing index.\n *\n * @param {number} index - Index of the pattern to remove\n */\nexport const deletePattern = index => {\n  // Collapse the sequence list first\n  sequence.update(patterns => {\n    return patterns.map(pattern => {\n      if (pattern > index) {\n        return pattern - 1;\n      }\n      return pattern;\n    });\n  });\n  patterns.update(patterns => {\n    patterns.splice(index, 1)\n    return patterns;\n  });\n  patternsMeta.update(meta => {\n    meta.splice(index, 1)\n    return meta;\n  });\n  patternMuteStates.update(states => {\n    states.splice(index, 1);\n    return states;\n  });\n};\n\n\n/**\n * Remove all patterns from the current song. Also resets the pattern number\n * used to generate pattern names.\n */\nexport const clearPatterns = () => {\n  patternNo = 0;\n  patterns.set([]);\n  patternsMeta.set([]);\n  patternMuteStates.set([]);\n};\n\n\n/**\n * Add a new track to an existing pattern using an optional instrument and\n * panning value.\n *\n * @param {number} pattern to add the track to\n * @param {number} instrument number to use for the track\n * @param {number} panning value for the track\n */\nexport const addChannel = (pattern, instrument = 0, panning = 0) => {\n  let newIndex;\n  patterns.update(patterns => {\n    newIndex = patterns[pattern].length;\n    const rowCount = patterns[pattern][0].length - 2;\n    patterns[pattern].push(createTrack(rowCount, instrument, panning));\n    return patterns;\n  });\n  patternMuteStates.update(states => {\n    states[pattern].push(false);\n    return states;\n  });\n  return newIndex;\n};\n\n\n/**\n * Delete a track from a pattern\n *\n * @param {*} pattern - Index of the pattern to delete the track from\n * @param {*} channel - Index of the track to delete\n */\nexport const deleteChannel = (pattern, channel) => {\n  patterns.update(patterns => {\n    patterns[pattern].splice(channel, 1);\n    return patterns;\n  });\n  patternMuteStates.update(states => {\n    states[pattern].splice(channel, 1);\n    return states;\n  });\n};\n\n\n/**\n * Add a blank row to each track in a pattern.\n * @param {number} pattern - Index of the pattern to add the row to\n */\nexport const addRow = pattern => {\n  let newIndex;\n  patterns.update(patterns => {\n    newIndex = patterns[pattern][0].length - 2;\n    patterns[pattern].forEach(channel => channel.push(0))\n    return patterns;\n  });\n  return newIndex;\n};\n\n\n/**\n * Removes a row from a pattern\n *\n * @param {number} pattern - Index of the pattern to remove the row from\n * @param {number} row - Index of the row to remove\n */\nexport const deleteRow = (pattern, row) => {\n  patterns.update(patterns => {\n    patterns[pattern].forEach(channel => {\n      channel.splice(row + 2, 1);\n    });\n    return patterns;\n  });\n};\n\n\n/**\n * Clears note and attenuation data from a row of a pattern\n *\n * @param {number} pattern - Index of the pattern to clear data from\n * @param {number} row - Index of the row to clear\n */\nexport const clearRow = (pattern, row) => {\n  patterns.update(patterns => {\n    patterns[pattern].forEach(track => {\n      track[row + 2] = 0;\n    });\n    return patterns;\n  });\n};\n\n\n/**\n * Creates an empty track object\n *\n * @param {number} rows - Number of rows in the ctrack\n * @param {number} instrument - Instrument for the track\n * @param {number} panning - Panning value for the track\n */\nexport const createTrack = (rows = 64, instrument = 0, panning = 0) => {\n  return [instrument, panning, ...new Array(rows).fill(0)];\n};\n\n\n/**\n * Creates an empty pattern object\n *\n * @param {*} tracks - Number of tracks for the new pattern\n * @param {*} rows - Number of rows for the new pattern\n */\nexport const createPattern = (tracks = 3, rows = 64) => {\n  return new Array(tracks).fill(0).map(() => createTrack(rows));\n};\n\n\n/**\n * Sets the data of a pattern\n *\n * @param {number} pattern - Index of the pattern to update\n * @param {Array} data - Data for the new pattern\n */\nexport const setPatternData = (pattern, data) => {\n  patterns.update(patterns => {\n    patterns[pattern] = data\n    return patterns;\n  });\n};\n\n\n/**\n * Adjust the attentuation of a note.\n *\n * @param {number} pattern - Index of the pattern containing the value to update\n * @param {number} channel - Index of the channel containing the value to update\n * @param {number} row - Index of the row containing the value to update\n * @param {number} step - Value to adjust attenutation by\n */\nexport const adjustAttenuation = (pattern, channel, row, step) => {\n  patterns.update(patterns => {\n    const channelRows = patterns[pattern][channel];\n    const note = channelRows[row + 2] | 0;\n    const attenuation = round(channelRows[row + 2] % 1, 2);\n    channelRows[row + 2] = note + clamp(attenuation + step, 0, .99);\n    return patterns;\n  });\n};\n\n\n/**\n * Set a note\n *\n * @param {number} pattern - Index of the pattern containing the note to update\n * @param {number} channel - Index of the channel containing the note to update\n * @param {number} row - Index of the row containing the note to update\n * @param {number} note - The new note\n */\nexport const setNote = (pattern, channel, row, note) => {\n  patterns.update(patterns => {\n    const channelRows = patterns[pattern][channel];\n    const currentAttenuation = round(channelRows[row + 2] % 1, 2);\n    channelRows[row + 2] = note + currentAttenuation;\n    return patterns;\n  });\n};\n\n\n/**\n * Returns a human-readable string for a note ID.\n *\n * @param {number} noteId - The note\n * @returns {string} The name of the note (e.g. `C#1`)\n */\nexport const getNoteName = noteId => NOTE_NAMES[noteId] || noteId;\n","import { patterns, sequence } from '../stores.js'\nimport { get } from 'svelte/store';\n\n// TODO: This is almost identical to below, consider making argument optional\n// and default to seq.length;\n\n/**\n * Calculates the total song length up to a specific sequence position\n * @param {*} sequencePos\n */\nexport const getCumlativeRowAtPosition = sequencePos => {\n  const patts = get(patterns);\n  const seq = get(sequence);\n  let row = 0;\n  sequencePos = sequencePos % (seq.length);\n  for (let sequenceIndex = 0; sequenceIndex < sequencePos; sequenceIndex++) {\n    row += patts[seq[sequenceIndex]][0].length - 2;\n  }\n  return row;\n}\n\n\n/**\n * Calculates the total song length in rows\n * @returns {number} Number of rows in the song\n */\nexport const getSongLength = () => {\n  const patts = get(patterns);\n  const seq = get(sequence);\n  let length = 0\n  for (let sequenceIndex = 0; sequenceIndex < seq.length; sequenceIndex++) {\n    length += patts[seq[sequenceIndex]][0].length - 2;\n  }\n  return length;\n}\n\n\n/**\n * Clears the current song sequence\n */\nexport const clearSequence = () => {\n  sequence.set([]);\n};\n","import { patterns, instruments, instrumentsMeta, patternsMeta, title, sequence, speed, meta } from '../stores.js'\nimport { get } from 'svelte/store';\nimport { decodeSong, encodeSong } from 'zzfxm-song-encoder';\nimport { addInstrument, clearInstruments, createInstrument } from '../services/InstrumentService.js';\nimport { addPattern, clearPatterns, createTrack } from '../services/PatternService.js';\nimport { clearSequence } from '../services/SequenceService.js';\nimport { removeEmptyStringValues } from '../lib/utils.js';\n\n/**\n * Clear out the current song so it can be populated with new data.\n */\nconst clearSong = () => {\n  clearSequence();\n  clearInstruments();\n  clearPatterns();\n};\n\n\n/**\n * Creates a new blank song and sets it as the current song\n */\nexport const createEmptySong = () => {\n  setSong([\n    [\n      createInstrument(1, 0, 400)\n    ],\n    [\n      [\n        createTrack(64, 0, -1),\n        createTrack(64, 0, 1),\n        createTrack(64, 0, -1),\n        createTrack(64, 0, 1)\n      ]\n    ],\n    [0],\n    125,\n    {\n      title: 'New Song'\n    }\n  ]);\n}\n\n\n/**\n * Sets the current song\n * @param {string} data\n */\nexport const setSong = song => {\n\n  clearSong();\n  meta.set(song[4] || {});\n  title.set(song[4] && song[4].title || 'Untitled song');\n  speed.set(song[3] || 125);\n  song[0].forEach((instrument, index) => {\n    const name = song[4] && song[4].instruments && song[4].instruments[index];\n    addInstrument(instrument, name);\n  });\n\n  song[1].forEach((pattern, index) => {\n    const name = song[4] && song[4].patterns && song[4].patterns[index];\n    addPattern(pattern, name);\n  });\n\n  sequence.set(song[2]);\n};\n\n\n/**\n * Serialises the current song into a string\n * @returns {string} the serialised song data\n */\n// TODO: rename to `serialize`?\nexport const serializeSong = (options = {}) => {\n  const tidyMeta = removeEmptyStringValues(get(meta));\n  let serializedMeta;\n\n  if (!options.noMeta) {\n    serializedMeta = {\n      ...tidyMeta,\n      ...{\n        title: get(title),\n        instruments: get(instrumentsMeta),\n        patterns: get(patternsMeta)\n      }\n    };\n  }\n\n  return encodeSong([\n    get(instruments),\n    get(patterns),\n    get(sequence),\n    get(speed),\n    serializedMeta\n  ]);\n};\n\n\n/**\n * Load song data from a File object and sets it as the current song.\n *\n * @param {File} file\n * @returns {Promise} A promise that resolves when the song has loaded\n */\nexport const loadSongFromFile = file => {\n  const url = URL.createObjectURL(file);\n  return loadSongFromUrl(url).finally(() => {\n    URL.revokeObjectURL(url);\n  });\n};\n\n\n/**\n * Load song data from a remote url and set it as the current song. Remote\n * servers must have the appropriate CORS response headers set for this to work.\n *\n * @param {string} url - The url of the song to load\n * @returns {Promise} A promise that resolves when the song has loaded\n */\nexport const loadSongFromUrl = url => {\n  return fetch(url)\n    .then(res => res.text())\n    .then(loadSongFromString)\n};\n\n\n/**\n * Load song data from a string and set it as the current song.\n *\n * @param {string} songString — The encoded song data\n */\nexport const loadSongFromString = songString => {\n  setSong(decodeSong(songString));\n};\n","import {\n  patternMuteStates,\n  uiFPS,\n  bufferSize,\n  sampleRate,\n  patterns,\n  instruments,\n  sequence,\n  speed,\n  selectedRow,\n  selectedPattern,\n  selectedSequence,\n  channelMeters,\n  masterVolume,\n  currentPlaybackLength,\n  songPlaying\n} from '../stores.js';\n\nimport {\n  getCumlativeRowAtPosition,\n  getSongLength\n} from './SequenceService.js';\n\nimport { get } from 'svelte/store';\n\n/**\n * @typedef PositionInfo\n * @property {number} sequence - The sequence position\n * @property {number} pattern - The pattern position\n * @property {number} row - The row index\n */\n\n/**\n * @typedef ChannelInfo\n * @property {number} panning - The stereo panning value of the channel\n * @property {number} attenuation - The current attenutationo f the channel\n * @property {number} sample - The instrument sample data for the channel\n * @property {number} offset - The current position of the sample data\n */\n\nlet processor;\nlet insts;\nlet patts;\nlet seq;\nlet spd;\nlet playbackSequence;\nlet targetUpdateFps;\nlet currentSongPosition;\nlet pos = 0;\nlet currentOffset = 0;\nlet channels = null;\nlet songLength;\nlet activeSoundCount = 0;\nlet currentBufferSize;\nlet isPlaying = false;\nlet frames = [];\nlet mutedTracks;\n\n\n// Create a gain node for the player volume. This is hooked up to a Svelte store\n// so it can be controlled via the user interface.\nconst gainNode = zzfxX.createGain();\ngainNode.connect(zzfxX.destination);\n\n\n// Stop zzfxX until sounds need to be played. This prevents the render service\n// from consuming system resources when not playing sounds.\nzzfxX.suspend();\n\n\n/**\n * Notify the service that a sound is about to be played. If no sounds are\n * currently playing the audio context will be resumed.\n *\n * @returns {Promise} A promise that resolves once the audio can be played.\n */\nconst registerSound = async () => {\n  if (activeSoundCount === 0) {\n    await zzfxX.resume();\n  }\n  activeSoundCount++;\n};\n\n\n/**\n * Notify the service that a sound has finished playing. If no other sounds are\n * currently playing the audio context will be suspended.\n *\n * @returns {Promise} A promise that resolves once the audio has stopped.\n */\n\nconst unregisterSound = async () => {\n  activeSoundCount--;\n  if (activeSoundCount === 0) {\n    await zzfxX.suspend();\n  }\n};\n\n\n/**\n * Creates a new ScriptProcessor instance using the currently configured service\n * options\n */\nconst initScriptProcessor = () => {\n  channels = null;\n  processor = zzfxX.createScriptProcessor(currentBufferSize, 0, 2);\n  processor.onaudioprocess = audioCallback;\n  processor.connect(gainNode);\n};\n\n\n/**\n * Destroys the current ScriptProcessor.\n */\nconst killScriptProcessor = () => {\n  processor.onaudioprocess = null;\n  processor.disconnect(gainNode);\n  processor = null;\n};\n\n\n/**\n * Sets the song position based on the current user selection\n */\nconst setPosition = () => {\n  pos = getCumlativeRowAtPosition(get(selectedSequence));\n  pos += get(selectedRow);\n  currentOffset = 0;\n  channels = null;\n};\n\n\n/**\n * Returns the current song position struct information data based on a position\n * index between 0 and total song rows.\n *\n * @param {number} position - the position to retreve data form\n * @returns {PositionInfo} The position information for the song row\n */\nconst getPositionInfo = (position) => {\n  let pos = 0;\n  let nextPos = 0;\n  for (let sequenceIndex = 0; sequenceIndex < playbackSequence.length; sequenceIndex++) {\n    let patternIndex = playbackSequence[sequenceIndex];\n    nextPos = pos + patts[patternIndex][0].length - 3;\n    if (nextPos >= position) {\n      return {\n        sequence: sequenceIndex,\n        pattern: patternIndex,\n        row: position - pos\n      };\n    }\n    pos = nextPos + 1;\n  }\n  return getPositionInfo(position % (nextPos + 1));\n};\n\n\n/**\n * Updates the current channel state based on the current song position and\n * steps forward one song row.\n *\n * @returns {PositionInfo}\n */\nconst next = () => {\n  pos %= songLength;\n  const position = getPositionInfo(pos);\n  const { pattern, row } = position;\n\n  if (!channels) {\n    channels = [];\n  }\n\n  patts[pattern].forEach((channel, i) => {\n    const data = channel[row + 2];\n    if (data) {\n      let note = data | 0;\n      let attenuation = data % 1;\n\n      if (note) {\n        if (note === -1) {\n          channels[i] = null\n          return;\n        }\n        channels[i] = {\n          panning: channel[1],\n          attenuation: attenuation,\n          sample: renderNote(channel[0], note),\n          offset: 0\n        }\n      }\n\n      if (attenuation) {\n        if (channels[i]) {\n          channels[i].attenuation = attenuation\n        }\n      }\n    }\n  });\n  pos++;\n  return position;\n};\n\n\n/**\n * Mix the sample data of a channel into the output buffers\n *\n * @param {ChannelInfo} channel - the channel\n * @param {number} start - the start position of the sample data\n * @param {number} length - the size of the sample data to copy\n * @param {Array<number>} leftChannelData - Left channel buffer\n * @param {Array<number>} rightChannelData - Right channel buffer\n * @returns {<number>} The peak value for the channel\n */\nconst mixChannelSampleData = (channel, start, length, leftChannelData, rightChannelData) => {\n  let peak = 0;\n\n  if (channel) {\n    const { panning, sample } = channel;\n    const step = zzfxR / zzfxX.sampleRate;\n    const sampleLength = sample.length;\n    let { attenuation } = channel;\n\n    for (let i = start; i < start + length; i++) {\n      if (channel.offset >= sampleLength) {\n        break;\n      }\n      // If we're approaching the end of the sample, quickly fade it out by\n      // increasing the attenuation to prevent clicking.\n      if (channel.offset > sampleLength - 99) {\n        attenuation += 1 / 99;\n      }\n      const data = (1 - attenuation) * sample[channel.offset | 0] || 0;\n      leftChannelData[i] += -data * panning + data;\n      rightChannelData[i] += data * panning + data;\n      peak = Math.min(1, Math.max(Math.abs(data), peak));\n      channel.offset += step;\n    }\n  }\n  return peak;\n};\n\n\n/**\n * Plays the currently configured pattern sequence.\n */\nconst play = async () => {\n  await registerSound();\n  initScriptProcessor();\n  songPlaying.set(true);\n  isPlaying = true;\n  updateUI();\n};\n\n\n/**\n * Updates the Svelte stores with new song data. Listeners will react to these\n * changes, triggering UI updates for the Peak Level meters, pattern row and, if\n * playing the entire song, the currently selected sequence and pattern.\n */\nconst updateUI = () => {\n  if (isPlaying) {\n    setTimeout(updateUI, 1000 / targetUpdateFps);\n  }\n  if (!frames.length) {\n    return;\n  }\n  const { sequence, pattern, row, peakLevels } = frames.shift();\n\n  // If the sequence is the actual song, make the pattern and sequence UI\n  // follow along with the current song position.\n  if (playbackSequence === seq) {\n    selectedSequence.set(sequence);\n    selectedPattern.set(pattern);\n  }\n  selectedRow.set(row);\n  channelMeters.set(peakLevels);\n};\n\n\n/**\n * Fills the output buffer with song data\n *\n * @param {AudioProcessingEvent} event - Audio processor event\n */\n\nconst audioCallback = event => {\n  const { outputBuffer } = event;\n  const dataL = outputBuffer.getChannelData(0).fill(0);\n  const dataR = outputBuffer.getChannelData(1).fill(0);\n  let bufferRemaining = outputBuffer.length;\n\n  let offset = 0;\n  frames = [];\n\n  // The length of one song row\n  const beatLength = zzfxX.sampleRate / spd * 60 >> 2;\n\n  // The length of sample data we need to process before notifying the UI that\n  // something needs to be updated. The UI target frame rate is variable so it\n  // can controlled by the end user.\n  const frameSize = zzfxX.sampleRate / targetUpdateFps;\n\n  // We we have no channel data from a previous step, get it now.\n  if (!channels) {\n    currentSongPosition = next();\n  }\n\n  // Fill the output buffer with our sample data.\n  while (bufferRemaining > 0) {\n\n    // Work out how much data we need to process\n    const beatDuration = Math.min(\n      bufferRemaining,\n      frameSize,\n      beatLength - currentOffset\n    );\n\n    if (currentOffset >= beatLength) {\n      currentSongPosition = next();\n      currentOffset -= beatLength;\n    }\n\n    // Mix the channel samples into the stereo output buffers\n    const peakLevels = channels.map((channel, channelIndex) => {\n      if (!mutedTracks[currentSongPosition.pattern][channelIndex]) {\n        return mixChannelSampleData(channel, offset, beatDuration, dataL, dataR);\n      }\n    });\n\n    // If we have a full frame of data, push state data for the UI scheduler to\n    // consume later. If we only push a partial frame the UI will render state\n    // incorrectly, causing flicker with peak meters.\n    if (offset === 0 || beatDuration >= frameSize) {\n      frames.push({...currentSongPosition, peakLevels});\n    }\n\n    offset += beatDuration;\n    currentOffset += beatDuration;\n    bufferRemaining -= beatDuration;\n  }\n};\n\n\n/**\n * Generates the sample data for a note played with an instrument\n *\n * @param {number} instrument - Index of the instrument to play\n * @param {number} note - Index of the note to play\n * @returns {Array<number>} Sample data\n */\nexport const renderNote = (instrument, note) => {\n  let instr = [...insts[instrument]];\n  instr[2] *= 2 ** ((note - 12) / 12);\n  return zzfxG(...instr);\n};\n\n\n\n\n/**\n * Plays a note with an instrument\n *\n * @param {number} instrument - Index of the instrument to play\n * @param {number} note - Index of the note to play\n * @returns {Promise} A promise that resolves with an AudioBufferSourceNode\n */\nexport const playNote = (instrument, note) => {\n  return playSample(renderNote(instrument, note));\n};\n\n\n/**\n * Plays a ZzFX sound\n *\n * @param {Array<number>} params - ZzFX instrument parameters\n * @returns {Promise} A promise that resolves with an AudioBufferSourceNode\n */\nexport const playSound = (params) => {\n  return playSample(zzfxG(...params));\n};\n\n\n/**\n * Plays sample data\n *\n * @param {Array<Array<number>>} data Audio channel data to play\n * @returns {Promise} A promise that resolves with an AudioBufferSourceNode\n */\nexport const playSample = async (data) => {\n  await registerSound();\n  const node = zzfxP([...data]);\n  node.onended = unregisterSound;\n  return node;\n};\n\n\n/**\n * Plays a pattern.\n *\n * @param {number} pattern - The pattern index to play\n * @param {boolean} fromStart - True to restart, false to resume\n */\nexport const playPattern = async (pattern, fromStart = false) => {\n  if (processor) {\n    return false;\n  }\n\n  playbackSequence = [pattern];\n\n  if (fromStart) {\n    pos = 0;\n  } else {\n    pos = get(selectedRow);\n  }\n  await play();\n};\n\n\n/**\n * Plays the current song from it's current position, or optionally from the\n * start\n *\n * @param {boolean} fromStart - True to restart, false to resume\n */\nexport const playSong = async (fromStart = false) => {\n  if (processor) {\n    return false;\n  }\n\n  playbackSequence = seq;\n\n  if (fromStart) {\n    pos = 0;\n  } else {\n    if (get(selectedSequence) === null) {\n      pos = 0;\n    } else {\n      setPosition();\n    }\n  }\n  await play();\n};\n\n\n/**\n * Stops playing the current song / pattern\n */\nexport const stopSong = async () => {\n  if (processor) {\n    killScriptProcessor();\n    songPlaying.set(false);\n    channelMeters.set([]);\n    isPlaying = false;\n    frames = [];\n    await unregisterSound();\n  }\n};\n\n\n// Subscribe to svelte stores so the renderer can react to state changes.\n\ninstruments.subscribe(value => insts = value);\n\nspeed.subscribe(value => spd = value);\n\ncurrentPlaybackLength.subscribe(value => songLength = value);\n\npatterns.subscribe(value => {\n  patts = value;\n  currentPlaybackLength.set(getSongLength());\n});\n\nsequence.subscribe(value => {\n  seq = value;\n  currentPlaybackLength.set(getSongLength());\n});\n\nmasterVolume.subscribe(value => {\n  gainNode.gain.value = value;\n});\n\nsampleRate.subscribe(value => {\n  zzfxR = value;\n  channels = null;\n});\n\nbufferSize.subscribe(value => {\n  if (isPlaying) {\n    killScriptProcessor();\n    currentBufferSize = value;\n    initScriptProcessor();\n  } else {\n    currentBufferSize = value;\n  }\n});\n\nuiFPS.subscribe(value => targetUpdateFps = value);\n\npatternMuteStates.subscribe(value => mutedTracks = value);\n","<script>\n  export let label = ''\n</script>\n\n<div class=\"field outset\">\n  <span class=\"field__label embossed\">{ label }</span>\n  <span class=\"field__controls inset\">\n    <slot />\n  </span>\n</div>\n\n<style>\n  .field {\n    display: flex;\n    padding: var(--field-padding);\n    align-items: center;\n  }\n  .field__label {\n    white-space: nowrap;\n  }\n  .field__controls {\n    display: inline-flex;\n    flex-wrap: wrap;\n  }\n  .field__controls > :global(*) {\n    flex: 1\n  }\n</style>\n","<script>\nexport let hint = '';\nexport let label = '';\nexport let disabled = false;\nexport let keyboard = '';\n\nlet title;\n\n$: if (hint && keyboard) {\n  title = `${hint}\\n\\nShortcut: ${keyboard}`;\n} else if (hint) {\n  title = `${hint}`;\n} else if (keyboard) {\n  title = `Shortcut: ${keyboard}`;\n}\n</script>\n\n<button class=\"outset\" {disabled} {title} on:click>{ label }</button>\n\n<style>\n  button {\n    background-color: var(--button-color);\n    border: none;\n    display: inline-block;\n    padding: var(--input-padding) 8px;\n    font: inherit;\n    text-transform: uppercase;\n    margin: 0;\n    white-space: nowrap;\n    letter-spacing: inherit;\n  }\n  button[disabled] {\n    color:#0005;\n  }\n  button:not([disabled]):hover {\n    background-color: var(--button-color-hover);\n  }\n  button:not([disabled]):active {\n    background-color: var(--button-color-press);\n  }\n</style>","<script>\n  import Button from './Button.svelte';\n\n  export let disabled = false;\n  export let keyboard = '';\n  export let playing = false;\n</script>\n\n<Button on:click label={playing ? 'Stop' : 'Play'} {disabled} {keyboard} />\n","<script>\nimport { sequence, patterns, currentPlaybackPosition, songPlaying } from '../stores.js';\nimport { playSong, stopSong } from '../services/RendererService.js';\nimport { createEventDispatcher, onDestroy, onMount } from 'svelte';\nimport Field from './Field.svelte';\nimport PlayButton from './PlayButton.svelte';\nimport Button from './Button.svelte';\nimport Toolbar from './Toolbar.svelte';\nimport Pane from './Pane.svelte';\n\nexport let selectedPosition = 0;\n\nlet markerElem;\nlet scrollElem;\nlet observer;\nlet userIsScrolling = false;\n\nconst dispatch = createEventDispatcher();\n\n\nconst handleAddClick = () => {\n  $sequence = [...$sequence, 0];\n  selectedPosition = $sequence.length - 1;\n  dispatch('select');\n}\n\nconst handleDeleteClick = () => {\n  $sequence = [...$sequence.slice(0, selectedPosition), ...$sequence.slice(selectedPosition + 1)];\n  selectedPosition = Math.min(selectedPosition, $sequence.length - 1);\n}\n\nconst togglePlaySongClick = () => {\n  if ($songPlaying) {\n    stopSong();\n  } else {\n    playSong();\n  }\n}\n\nconst select = position => {\n  selectedPosition = position;\n  dispatch('select');\n}\n\nconst moveLeft = () => {\n  $sequence = [\n    ...$sequence.slice(0, selectedPosition - 1),\n    $sequence[selectedPosition],\n    $sequence[selectedPosition-1],\n    ...$sequence.slice(selectedPosition + 1)\n  ];\n  selectedPosition--;\n}\n\nconst moveRight = () => {\n  $sequence = [\n    ...$sequence.slice(0, selectedPosition),\n    $sequence[selectedPosition+1],\n    $sequence[selectedPosition],\n    ...$sequence.slice(selectedPosition + 2)\n  ];\n  selectedPosition++;\n}\n\nconst handleUserScroll = () => {\n  if (!userIsScrolling) {\n    setTimeout(() => userIsScrolling = false, 500);\n    userIsScrolling = true;\n  }\n}\n\nconst color = seq => `hsl(${90+seq*20},35%,50%)`;\n\n$: hasSelection = selectedPosition !== null;\n\n// Ensure the position marker is always visible when the song is playing by\n// scrolling it into view.\n$: if (markerElem) {\n  if ($songPlaying) {\n    observer.observe(markerElem);\n  } else {\n    observer.unobserve(markerElem);\n  }\n}\n\nonMount(() => {\n  observer = new IntersectionObserver(entries => {\n    if (!entries[0].isIntersecting && !userIsScrolling) {\n      markerElem.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n        inline: 'center'\n      })\n    }\n  }, {\n    root: scrollElem,\n    threshold: [0, 1]\n  });\n\n  // Mark that the user started scrolling so we don't override their input and\n  // scroll the marker back into view.\n  scrollElem.addEventListener('scroll', handleUserScroll);\n});\n\nonDestroy(() => {\n  observer.disconnect();\n  scrollElem.removeEventListener('scroll', handleUserScroll);\n});\n\n</script>\n\n<Pane>\n  <div slot=\"head\">\n    <Toolbar>\n      <Field label=\"Sequence\">\n        <Button label=\"Add\" on:click={handleAddClick} />\n        <Button label=\"Delete\" disabled={!hasSelection} on:click={handleDeleteClick} />\n        <Button label=\"Move Left\" disabled={!hasSelection || selectedPosition === 0} on:click={moveLeft} />\n        <Button label=\"Move Right\" disabled={!hasSelection || selectedPosition === $sequence.length - 1}  on:click={moveRight} />\n      </Field>\n      <Field label=\"Playback\">\n        <PlayButton playing={$songPlaying} keyboard=\"ALT + ENTER\" on:click={togglePlaySongClick} />\n      </Field>\n      <div class=\"outset\"></div>\n    </Toolbar>\n  </div>\n\n  <div class=\"sequence\" bind:this={scrollElem}>\n    <div class=\"sequence__patterns\">\n      <div class=\"marker\" style=\"transform:translateX({$currentPlaybackPosition}px\" bind:this={markerElem}></div>\n      {#each $sequence as sequence, i}\n        <div on:click={()=>select(i)} class:selected={i === selectedPosition} class=\"pattern\" style=\"background: { color(sequence) }; max-width: { $patterns[sequence][0].length - 2 }px;min-width: { $patterns[sequence][0].length - 2}px\">\n          {#if i === selectedPosition}\n            <select class=\"select\" bind:value={sequence} on:input>\n              {#each $patterns as pattern, i}\n                <option value={i}>{i}</option>\n              {/each}\n            </select>\n          {:else}\n            {sequence}\n          {/if}\n        </div>\n      {/each}\n    </div>\n  </div>\n</Pane>\n\n<style>\n  .sequence {\n    overflow: auto;\n    scrollbar-width: none;\n    -ms-overflow-style: none;\n  }\n  .sequence::-webkit-scrollbar {\n    height: 0px;\n    background: transparent;\n  }\n  .sequence__patterns {\n    display: flex;\n    padding: var(--field-padding);\n    position: relative;\n  }\n  .pattern {\n    text-align: center;\n    border: 1px solid #0004;\n    border-radius: 4px;\n    padding: var(--field-padding);\n  }\n  .selected {\n    border-color: var(--focus-ring-color);\n    width: auto !important;\n    line-height: inherit;\n  }\n  .marker {\n    position:absolute;\n    width:3px;\n    top:0;\n    bottom:0;\n    margin-left:-1px;\n    background:#f008;\n    will-change: transform;\n  }\n  .select {\n    background-color: #fffa;\n    border-radius: 2px;\n    box-shadow: 0 0 1px #000;\n  }\n</style>\n","<script>\nimport Button from './Button.svelte';\n\nexport let hint = '';\nexport let label = '';\nexport let disabled = false;\nexport let keyboard = '';\nexport let checked = false;\n\nconst handleToggleClick = () => {\n  checked = !checked;\n}\n</script>\n\n<span class:checked class=\"toggleButton\">\n  <Button on:click on:click={handleToggleClick} {label} {disabled} {keyboard} {hint} />\n</span>\n\n<style>\n  .toggleButton {\n    display: inline-flex;\n  }\n  .toggleButton > :global(*) {\n    flex: 1;\n  }\n  .toggleButton > :global(*)::before {\n    content: '';\n    display: inline-block;\n    border-radius: 8px;\n    width: 8px;\n    height: 8px;\n    margin-right: 4px;\n    background-color: var(--indicator-color);\n    box-shadow: .5px .5px 0px .5px #fff4, -.5px -.5px 0px .5px #0004, inset 1px 1px 0 0 #fff9, inset -1px -1px 0 0 #0006;\n    border: 1px solid #000c;\n  }\n  .toggleButton {\n    --indicator-color: #333;\n  }\n  .checked {\n    --indicator-color: #f35;\n  }\n</style>","let globalId = 0;\n\n/**\n * Creates an app-unique element ID.\n */\nexport const createElementId = () => {\n  return `elm-${globalId++}`;\n};\n","<script>\n  const PATHS = {\n    warning: 'M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5a.905.905 0 0 0-.9.995l.35 3.507a.552.552 0 0 0 1.1 0l.35-3.507A.905.905 0 0 0 8 5zm.002 6a1 1 0 1 0 0 2 1 1 0 0 0 0-2z'\n  };\n\n  export let name = '';\n</script>\n\n<svg viewBox=\"0 0 16 16\">\n  <path fill-rule=\"evenodd\" d={PATHS[name]}>\n</svg>\n\n<style>\n  svg {\n    width: 1em;\n    height: 1em;\n    fill: currentColor;\n    display:block;\n  }\n</style>\n","<script>\nimport Icon from './Icon.svelte';\n\nexport let reason = '';\n</script>\n\n<span class=\"warning\" title=\"{reason}\">\n  <Icon name=\"warning\"></Icon>\n</span>\n\n<style>\n.warning {\n  color: #fc0;\n  filter:drop-shadow(0 0 .5px #000);\n}\n</style>","<script>\n  import { createElementId } from '../services/DomService.js';\n  import WarningIndicator from './WarningIndicator.svelte';\n\n  export let label = '';\n  export let hint = null;\n  export let warning = null;\n\n  let id = createElementId();\n</script>\n\n<div class=\"property outset\" title={hint}>\n  <label for={id} class=\"property__label embossed\">{ label }</label>\n  {#if warning}<WarningIndicator reason={ warning } />{/if}\n  <span class=\"property__controls inset\">\n    <slot {id} />\n  </span>\n</div>\n\n<style>\n  .property {\n    display: flex;\n    padding: var(--field-padding);\n    align-items: center;\n  }\n  .property__label {\n    flex: 1;\n    white-space: nowrap;\n    padding-right:6px;\n  }\n  .property__controls {\n    display: inline-flex;\n  }\n  .property > :global(.warning) {\n    margin-right: var(--field-padding);\n  }\n</style>\n","<script>\n  import Property from './Property.svelte';\n  export let label = '';\n  export let value = '';\n  export let hint = '';\n  export let size = 14;\n  export let multiline = false;\n</script>\n\n<Property {label} {hint} let:id={id}>\n  {#if multiline}\n    <textarea {id} style=\"width: {size+1}ch\" rows=\"5\" spellcheck=\"false\" class=\"input\" bind:value={value}></textarea>\n  {:else}\n    <input {id} style=\"width: {size+1}ch\" spellcheck=\"false\" type=\"text\" class=\"input\" bind:value={value}>\n  {/if}\n</Property>\n\n<style>\n  textarea {\n    resize: none;\n  }\n</style>\n","<script>\n\n  import Property from './Property.svelte';\n\n  export let label = '';\n  export let value = 0;\n  export let min = 0;\n  export let max = 1;\n  export let step = 1;\n  export let size = 1;\n  export let hint = '';\n  export let warning = '';\n\n  const fineStep = step;\n  const coarseStep = step * 10;\n\n  let lastGoodValue = value;\n  let elem;\n\n  const setValue = () => {\n    elem.value = value = lastGoodValue;\n  }\n\n  const setValueIfValid = event => {\n    const newValue = parseFloat(elem.value);\n    if ((newValue === 0 && elem.value.length > 1) || !validateValue(newValue)) {\n      event.stopImmediatePropagation();\n      return;\n    }\n    lastGoodValue = value = newValue;\n  }\n\n  const validateValue = value => {\n    return !isNaN(value) && value >= min && value <= max;\n  }\n\n  const handleKeyDown = event => {\n    if (event.shiftKey) {\n      step = coarseStep;\n    } else {\n      step = fineStep;\n    }\n  }\n</script>\n\n<Property {label} {hint} {warning} let:id={id}>\n  <input {id} bind:this={elem} style=\"width: { size + 4 }ch\" class=\"input\" type=\"number\" {step} {min} {max} value={value} on:focus={lastGoodValue=value} on:keydown={handleKeyDown} on:change={setValue} on:input={setValueIfValid} on:input on:change>\n</Property>\n","<script>\nimport { onDestroy, onMount } from \"svelte\";\n\nlet canvas;\nlet debounce = false;\nlet canvasWidth;\nlet canvasHeight;\n\nexport let data;\n\n$: if (data) {\n  generateSampleView();\n}\n\nif ('ResizeObserver' in window) {\n  const resizeObserver = new ResizeObserver(entries => {\n    for (const entry of entries) {\n      const {width, height} = entry.contentRect;\n      canvasWidth = width;\n      canvasHeight = height;\n\n      if (!debounce) {\n        debounce = true;\n        generateSampleView();\n        setTimeout(() => {\n          generateSampleView();\n          debounce = false;\n        }, 500);\n      }\n    }\n  });\n\n  onMount(() => {\n    resizeObserver.observe(canvas.parentElement);\n  });\n\n  onDestroy(() => {\n    resizeObserver.unobserve(canvas.parentElement);\n  });\n\n} else {\n  // Browser doesn't support ResizeObserver so let's used the initial values\n  // so the user can see _something_.\n  onMount(() => {\n    canvasWidth = canvas.parentElement.clientWidth;\n    canvasHeight = canvas.parentElement.clientHeight;\n  });\n}\n\nconst generateSampleView = () => {\n  if (!canvas) {\n    return\n  }\n  const context = canvas.getContext('2d');\n  canvas.height = canvasHeight;\n  canvas.width = canvasWidth;\n  context.strokeStyle = '#0004';\n  context.beginPath();\n\n  context.moveTo(0, canvasHeight / 2 - .5);\n  context.lineTo(canvasWidth, canvasHeight / 2 -.5);\n  context.stroke();\n  context.closePath();\n\n  context.strokeStyle = '#062';\n  context.beginPath();\n  for (let c = 0; c < canvasWidth; c += 2) {\n    const p = c * (data.length / canvasWidth) | 0;\n    const y = (.5 + data[p]) * canvasHeight | 0;\n    if (c === 0) {\n      context.moveTo(0, y);\n    } else {\n      context.lineTo(c - .5, y);\n    }\n  }\n  context.stroke();\n  context.closePath();\n}\n\n</script>\n\n<div>\n  <canvas class=\"inset\" bind:this={canvas}></canvas>\n</div>\n\n<style>\n  div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n  canvas {\n    position:absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    border: var(--field-padding) solid var(--outset-color)\n  }\n</style>\n","export const hihat = [2,0,4e3,,,.03,2,1.25,,,,,.02,6.8,-0.3,,.5];\nexport const claps = [1,0,655,,,.11,2,1.65,,,,,,3.8,-0.1,.1];\nexport const bassDrum = [1,0,84,,,.1,,.7,,,,.5,,6.7,1,.05];\nexport const bassDrum2 = [3,0,43,0,,0.25,,,,,,,,2];\nexport const snare = [1,0,655,0,,.09,3,1.65,,,,,.02,3.8,-0.1,,.2];\nexport const snare2 = [1,0,219,,,,,1.1,,-.1,-50,-.05,-.01,1];\nexport const hihatOpen = [.8,0,2100,,,.2,3,3,,,-400,,,2];\nexport const shaker = [.3,0,900,.02,,.07,4,0,,,,,,4];\n","export const korgBass = [.7,0,22,,.07,.07,2,0,,,.5,.01];\nexport const korgFilter = [,0,245,0,0,0.48,2,,0,0,0,,,,0,0.02,0.01];\nexport const piano = [.5,0,196,,.08,.5,3];\nexport const ringPiano = [0.75,0,196,0,0.08,0.18,3];\nexport const polySynth = [,0,25,0.002,0.02,0.08,3,,,,,,,,,0.1,0.01];\nexport const synthBrass = [0.9,0,143,,,.35,3,,,,,,,,,];\nexport const hallBrass = [,0,232,.01,.09,.15,2,,,,,,154.87,,,,.26];\nexport const digDug = [,0,23,,,.2,3,5,,,0];\n","export const flute = [,0,740,0,,0.15,2,0.2,-0.1,-0.15,9,0.02,,0.1,0.12,0,0.06];","<script>\nimport { playSound } from '../services/RendererService';\nimport { createEventDispatcher } from 'svelte';\nimport Button from './Button.svelte';\nimport { percussion, keyboards, wind } from 'zzfxm-instruments';\n\nconst dispatch = createEventDispatcher();\n\nconst format = v => {\n  return v.substr(0,1).toUpperCase() + v.substr(1).replace(/[A-Z0-9]/g, ' $&')\n}\n\nconst instruments = Object.entries({percussion, keyboards, wind}).map(([name, items]) => ({\n  label: format(name),\n  instruments: Object.entries(items).map(([name, value]) => ({\n      name: format(name),\n      params: value\n    })\n  )\n}));\n\nlet group = instruments[0];\nlet selection = null;\n\n\nconst handleChange = () => {\n  if (selection) {\n    playSound(selection.params);\n  }\n};\n\nconst handleApplyClick = () => {\n  dispatch('apply', selection);\n};\n</script>\n\n<div class=\"wrap\">\n  <div class=\"splitView\">\n    <div class=\"inset\">\n      <select class=\"select\" size=\"2\" bind:value={group}>\n        {#each instruments as group}\n          <option value={group}>{group.label}</option>\n        {/each}\n      </select>\n    </div>\n    <div class=\"inset\">\n      <select class=\"select\" size=\"2\" bind:value={selection} on:change={handleChange}>\n        {#each group.instruments as instrument (instrument)}\n          <option value={instrument}>{instrument.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n  <div>\n    <Button label=\"Apply\" disabled={!selection} on:click={handleApplyClick} />\n  </div>\n</div>\n\n<style>\n.wrap {\n  display: grid;\n  grid-template-rows: 1fr auto;\n  gap: var(--modal-spacing);\n}\n.splitView,.select {\n  width:100%;\n  height:100%;\n}\n.splitView {\n  height: 20em;\n}\n</style>","export { identity as linear } from '../internal';\n\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\nfunction backInOut(t) {\n    const s = 1.70158 * 1.525;\n    if ((t *= 2) < 1)\n        return 0.5 * (t * t * ((s + 1) * t - s));\n    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\nfunction backIn(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n}\nfunction backOut(t) {\n    const s = 1.70158;\n    return --t * t * ((s + 1) * t + s) + 1;\n}\nfunction bounceOut(t) {\n    const a = 4.0 / 11.0;\n    const b = 8.0 / 11.0;\n    const c = 9.0 / 10.0;\n    const ca = 4356.0 / 361.0;\n    const cb = 35442.0 / 1805.0;\n    const cc = 16061.0 / 1805.0;\n    const t2 = t * t;\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfunction bounceInOut(t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfunction bounceIn(t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfunction circInOut(t) {\n    if ((t *= 2) < 1)\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\nfunction circIn(t) {\n    return 1.0 - Math.sqrt(1.0 - t * t);\n}\nfunction circOut(t) {\n    return Math.sqrt(1 - --t * t);\n}\nfunction cubicInOut(t) {\n    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfunction cubicIn(t) {\n    return t * t * t;\n}\nfunction cubicOut(t) {\n    const f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfunction elasticInOut(t) {\n    return t < 0.5\n        ? 0.5 *\n            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *\n            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 *\n            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *\n            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +\n            1.0;\n}\nfunction elasticIn(t) {\n    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction elasticOut(t) {\n    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);\n}\nfunction expoInOut(t) {\n    return t === 0.0 || t === 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)\n            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\nfunction expoIn(t) {\n    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction expoOut(t) {\n    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\nfunction quadInOut(t) {\n    t /= 0.5;\n    if (t < 1)\n        return 0.5 * t * t;\n    t--;\n    return -0.5 * (t * (t - 2) - 1);\n}\nfunction quadIn(t) {\n    return t * t;\n}\nfunction quadOut(t) {\n    return -t * (t - 2.0);\n}\nfunction quartInOut(t) {\n    return t < 0.5\n        ? +8.0 * Math.pow(t, 4.0)\n        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\nfunction quartIn(t) {\n    return Math.pow(t, 4.0);\n}\nfunction quartOut(t) {\n    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfunction quintInOut(t) {\n    if ((t *= 2) < 1)\n        return 0.5 * t * t * t * t * t;\n    return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\nfunction quintIn(t) {\n    return t * t * t * t * t;\n}\nfunction quintOut(t) {\n    return --t * t * t * t * t + 1;\n}\nfunction sineInOut(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\nfunction sineIn(t) {\n    const v = Math.cos(t * Math.PI * 0.5);\n    if (Math.abs(v) < 1e-14)\n        return 1;\n    else\n        return 1 - v;\n}\nfunction sineOut(t) {\n    return Math.sin((t * Math.PI) / 2);\n}\n\nexport { backIn, backInOut, backOut, bounceIn, bounceInOut, bounceOut, circIn, circInOut, circOut, cubicIn, cubicInOut, cubicOut, elasticIn, elasticInOut, elasticOut, expoIn, expoInOut, expoOut, quadIn, quadInOut, quadOut, quartIn, quartInOut, quartOut, quintIn, quintInOut, quintOut, sineIn, sineInOut, sineOut };\n","import { cubicInOut, linear, cubicOut } from '../easing';\nimport { is_function, assign } from '../internal';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nfunction blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 }) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const f = style.filter === 'none' ? '' : style.filter;\n    const od = target_opacity * (1 - opacity);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`\n    };\n}\nfunction fade(node, { delay = 0, duration = 400, easing = linear }) {\n    const o = +getComputedStyle(node).opacity;\n    return {\n        delay,\n        duration,\n        easing,\n        css: t => `opacity: ${t * o}`\n    };\n}\nfunction fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const od = target_opacity * (1 - opacity);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);\n\t\t\topacity: ${target_opacity - (od * u)}`\n    };\n}\nfunction slide(node, { delay = 0, duration = 400, easing = cubicOut }) {\n    const style = getComputedStyle(node);\n    const opacity = +style.opacity;\n    const height = parseFloat(style.height);\n    const padding_top = parseFloat(style.paddingTop);\n    const padding_bottom = parseFloat(style.paddingBottom);\n    const margin_top = parseFloat(style.marginTop);\n    const margin_bottom = parseFloat(style.marginBottom);\n    const border_top_width = parseFloat(style.borderTopWidth);\n    const border_bottom_width = parseFloat(style.borderBottomWidth);\n    return {\n        delay,\n        duration,\n        easing,\n        css: t => `overflow: hidden;` +\n            `opacity: ${Math.min(t * 20, 1) * opacity};` +\n            `height: ${t * height}px;` +\n            `padding-top: ${t * padding_top}px;` +\n            `padding-bottom: ${t * padding_bottom}px;` +\n            `margin-top: ${t * margin_top}px;` +\n            `margin-bottom: ${t * margin_bottom}px;` +\n            `border-top-width: ${t * border_top_width}px;` +\n            `border-bottom-width: ${t * border_bottom_width}px;`\n    };\n}\nfunction scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 }) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const sd = 1 - start;\n    const od = target_opacity * (1 - opacity);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (_t, u) => `\n\t\t\ttransform: ${transform} scale(${1 - (sd * u)});\n\t\t\topacity: ${target_opacity - (od * u)}\n\t\t`\n    };\n}\nfunction draw(node, { delay = 0, speed, duration, easing = cubicInOut }) {\n    const len = node.getTotalLength();\n    if (duration === undefined) {\n        if (speed === undefined) {\n            duration = 800;\n        }\n        else {\n            duration = len / speed;\n        }\n    }\n    else if (typeof duration === 'function') {\n        duration = duration(len);\n    }\n    return {\n        delay,\n        duration,\n        easing,\n        css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`\n    };\n}\nfunction crossfade(_a) {\n    var { fallback } = _a, defaults = __rest(_a, [\"fallback\"]);\n    const to_receive = new Map();\n    const to_send = new Map();\n    function crossfade(from, node, params) {\n        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = cubicOut } = assign(assign({}, defaults), params);\n        const to = node.getBoundingClientRect();\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n        const dw = from.width / to.width;\n        const dh = from.height / to.height;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        const opacity = +style.opacity;\n        return {\n            delay,\n            duration: is_function(duration) ? duration(d) : duration,\n            easing,\n            css: (t, u) => `\n\t\t\t\topacity: ${t * opacity};\n\t\t\t\ttransform-origin: top left;\n\t\t\t\ttransform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});\n\t\t\t`\n        };\n    }\n    function transition(items, counterparts, intro) {\n        return (node, params) => {\n            items.set(params.key, {\n                rect: node.getBoundingClientRect()\n            });\n            return () => {\n                if (counterparts.has(params.key)) {\n                    const { rect } = counterparts.get(params.key);\n                    counterparts.delete(params.key);\n                    return crossfade(rect, node, params);\n                }\n                // if the node is disappearing altogether\n                // (i.e. wasn't claimed by the other list)\n                // then we need to supply an outro\n                items.delete(params.key);\n                return fallback && fallback(node, params, intro);\n            };\n        };\n    }\n    return [\n        transition(to_send, to_receive, false),\n        transition(to_receive, to_send, true)\n    ];\n}\n\nexport { blur, crossfade, draw, fade, fly, scale, slide };\n","<script>\nimport Button from './Button.svelte';\nimport { fade, fly } from 'svelte/transition';\n\nexport let open = false;\nexport let title = '';\n\nconst handleKeyPress = e => {\n  if (!open) {\n    return;\n  }\n  if (e.key === 'Escape') {\n    close();\n    e.preventDefault();\n  }\n};\n\nconst close = () => {\n  open = false;\n};\n</script>\n\n{#if open}\n  <div class=\"overlay\" transition:fade={{duration: 150}}></div>\n  <dialog class=\"modal\" transition:fly={{duration: 150, y: 10}}>\n    <div class=\"modal__header outset embossed\">\n      {title} <Button label=\"×\" on:click={close} />\n    </div>\n    <div class=\"modal__body outset\"><slot /></div>\n  </dialog>\n{/if}\n\n<svelte:window on:keydown={handleKeyPress}/>\n\n<style>\n.modal {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  width: 500px;\n  max-height: calc(100vh - 32px);\n  transform: translate(-50%,-50%);\n  box-shadow: 0 2px 5px 2px #0008;\n  display: grid;\n  grid-template-rows: auto 1fr auto;\n  z-index: 1;\n  border: none;\n  margin: 0;\n  padding: 0;\n}\n.modal__header {\n  padding: var(--modal-spacing);\n}\n.modal__header {\n  --outset-color: var(--toolbar-color);\n  display: grid;\n  grid-template-columns: 1fr auto;\n  align-items: center;\n}\n.modal__body {\n  padding: var(--panel-spacing);\n  background: var(--body-color);\n  overflow: auto;\n}\n.overlay {\n  content: '';\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: #0006;\n}\n</style>\n","<script>\nimport { instrumentsMeta, patterns, instruments } from '../stores.js';\nimport { playNote } from '../services/RendererService.js';\nimport { getNoteName } from '../services/PatternService.js';\nimport { addInstrument, deleteInstrument, setInstrumentParams } from '../services/InstrumentService.js';\nimport { decodeInstrument, encodeInstrument } from 'zzfxm-song-encoder';\nimport { clamp } from '../lib/utils.js';\nimport { tick } from 'svelte';\nimport Pane from './Pane.svelte';\nimport Toolbar from './Toolbar.svelte';\nimport Button from './Button.svelte';\nimport ToggleButton from './ToggleButton.svelte';\nimport Field from './Field.svelte';\nimport Property from './Property.svelte';\nimport TextProperty from './TextProperty.svelte';\nimport NumberProperty from './NumberProperty.svelte';\nimport SampleViewer from './SampleViewer.svelte';\nimport InstrumentPicker from './InstrumentPicker.svelte';\nimport Modal from './Modal.svelte';\n\nexport let selected = 0;\n\nconst notelist = new Array(36).fill(0).map((value, index) => {\n  return {\n    id: index + 1,\n    label: getNoteName(index + 2)\n  }\n});\n\nconst shapeOptions = [\n  {id: 0, label: 'Sin'},\n  {id: 1, label: 'Triangle'},\n  {id: 2, label: 'Saw'},\n  {id: 3, label: 'Tan'},\n  {id: 4, label: 'Bit Noise'},\n];\n\nlet clipboard;\nlet showInstrumentPicker = false;\nlet playOnChange = true;\nlet testNote = 13;\nlet currentNote;\n\nconst waveformCache = new WeakMap();\n\n$: selected = clamp(selected, 0, $instruments.length - 1);\n$: instrument = $instruments[selected];\n$: buffer = getWave(instrument);\n$: usage = $patterns.map((pattern, i) => {\n  return pattern.some(channel => channel[0] === selected) && i\n}).filter(x => x !== false);\n\nconst getWave = (instrument, recache) => {\n  if (recache || !waveformCache.has(instrument)) {\n    const buffer = zzfxG(...instrument);\n    const step = Math.max(1, (buffer.length / 2000) | 0);\n    const previewBuffer = buffer.filter((v, i) => i % step === 0);\n    waveformCache.set(instrument, previewBuffer);\n  }\n  return waveformCache.get(instrument);\n};\n\nconst playTestNote = async (instrument, note) => {\n  if (currentNote) {\n    currentNote.stop();\n  }\n  currentNote = await playNote(instrument, note);\n}\n\nconst handlePlayClick = () => {\n  playTestNote(selected, testNote);\n}\n\nconst handleChange = async () => {\n  if (playOnChange) {\n    playTestNote(selected, testNote);\n  }\n  await tick();\n  buffer = getWave(instrument, true);\n}\n\nconst handleImportClick = () => {\n  let code = prompt('Zzfx Code', `zzfx(...[])`);\n  if (code) {\n    code = code.replace(/zzfx\\(\\.\\.\\.(\\[[\\w\\W]*?\\])\\)/, '$1');\n    setInstrumentParams(selected, decodeInstrument(code));\n  }\n}\n\nconst handleExportClick = () => {\n  prompt('Zzfx Code', `zzfx(...${encodeInstrument(instrument)})`);\n}\n\nconst handleAddClick = () => {\n  addInstrument([1,0]);\n  selected = $instruments.length - 1;\n}\n\nconst handleDeleteClick = () => {\n  if (usage.length > 0) {\n    alert(`This instrument is being used in patterns ${usage}.`)\n  } else {\n    deleteInstrument(selected);\n    selected = Math.min(selected,$instruments.length - 1);\n  }\n}\n\nconst handleSelectClick = () => {\n  showInstrumentPicker = true;\n}\n\nconst handleInstrumentApply = e => {\n  setInstrumentParams(selected, e.detail.params);\n  $instrumentsMeta[selected] = e.detail.name;\n  showInstrumentPicker = false;\n}\n\nconst copy = () => {\n  clipboard = instrument.slice();\n}\n\nconst paste = () => {\n  $instruments[selected] = clipboard.slice();\n  $instruments = $instruments;\n}\n</script>\n\n\n<div class=\"splitView\">\n  <Pane>\n    <div slot=\"head\">\n      <Toolbar>\n        <Field label=\"Instruments\">\n          <Button label=\"Add\" on:click={handleAddClick} />\n          <Button label=\"Delete\" disabled={usage.length} on:click={handleDeleteClick} />\n          <Button label=\"Copy\" on:click={copy}  />\n          <Button label=\"Paste\" on:click={paste} disabled={!clipboard} />\n        </Field>\n      </Toolbar>\n    </div>\n    <select class=\"select\" bind:value={selected} size=\"2\">\n      {#each $instrumentsMeta as instrument, i}\n        <option value={i}>{i}: {instrument}</option>\n      {/each}\n    </select>\n  </Pane>\n\n  <Pane>\n    <div slot=\"head\">\n      <Toolbar>\n        <NumberProperty min={0} max={$instruments.length - 1} label=\"#\" bind:value={selected} />\n        <TextProperty label=\"Name\" bind:value={$instrumentsMeta[selected]} />\n        <Field label=\"Playback\">\n          <Button label=\"Play\" on:click={handlePlayClick} />\n          <select class=\"select\" bind:value={testNote}>\n            {#each notelist as note}\n              <option value={note.id}>{note.label}</option>\n            {/each}\n          </select>\n          <ToggleButton hint=\"Automatically play when changing properties\" label=\"Auto Play\" bind:checked={playOnChange} />\n        </Field>\n        <Field label=\"Parameters\">\n          <Button label=\"Import\" on:click={handleImportClick} />\n          <Button label=\"Export\" on:click={handleExportClick} />\n          <Button label=\"Library\" on:click={handleSelectClick} />\n        </Field>\n        <Field label=\"Pattern Usage\"><span class=\"usage output\">{usage.length ? usage : 'Unused'}</span></Field>\n        <div class=\"outset\"></div>\n      </Toolbar>\n    </div>\n\n    <div class=\"instrument\">\n      <div class=\"instrument__params\">\n        <NumberProperty size={4} label=\"Volume\" hint=\"Volume scale (percent)\" min=\"0\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[0]} />\n        <NumberProperty size={4} label=\"Frequency\" hint=\"Frequency of sound (Hz)\" min=\"-1000000000\" max=\"1000000000\" step=\"1\" on:input={handleChange} bind:value={instrument[2]} />\n        <Property label=\"Shape\">\n          <select class=\"select\" on:input={handleChange} bind:value={instrument[6]}>\n            {#each shapeOptions as option}\n              <option value={option.id}>{option.label}</option>\n            {/each}\n          </select>\n        </Property>\n        <NumberProperty size={4} label=\"Attack\" hint=\"Attack time, how fast sound starts (seconds)\" min=\"0\" max=\"3\" step=\"0.01\" on:input={handleChange} bind:value={instrument[3]} />\n        <NumberProperty size={4} label=\"Sustain\" hint=\"Sustain time, how long sound holds (seconds)\" min=\"0\" max=\"3\" step=\"0.01\" on:input={handleChange} bind:value={instrument[4]} />\n        <NumberProperty size={4} label=\"Release\" hint=\"Release time, how fast sound fades out (seconds)\" min=\"0\" max=\"3\" step=\"0.01\" on:input={handleChange} bind:value={instrument[5]} />\n        <NumberProperty size={4} label=\"Shape Curve\" hint=\"Squarenes of wave (0=square, 1=normal, 2=pointy)\" min=\"0\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[7]} />\n        <NumberProperty size={4} label=\"Slide\" hint=\"How much to slide frequency (kHz/s)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[8]} />\n        <NumberProperty size={4} label=\"Delta Slide\" hint=\"How much to change slide (kHz/s/s)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[9]} />\n        <NumberProperty size={4} label=\"Pitch Jump\" hint=\"Frequency of pitch jump (Hz)\" min=\"-1000000000\" max=\"1000000000\" step=\"10\" on:input={handleChange} bind:value={instrument[10]} />\n        <NumberProperty size={4} label=\"Pitch Jump Time\" hint=\"Time of pitch jump (seconds)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.01\" on:input={handleChange} bind:value={instrument[11]} />\n        <NumberProperty size={4} label=\"Repeat Time\" hint=\"Resets some parameters periodically (seconds)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.01\" on:input={handleChange} bind:value={instrument[12]} />\n        <NumberProperty size={4} label=\"Noise\" hint=\"How much random noise to add (percent)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[13]} />\n        <NumberProperty size={4} label=\"Modulation\" hint=\"Frequency of modulation wave, negative flips phase (Hz)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[14]} />\n        <NumberProperty size={4} label=\"Bit Crush\" hint=\"Resamples at a lower frequency in (samples*100)\" min=\"-1000000000\" max=\"1000000000\" step=\"0.1\" on:input={handleChange} bind:value={instrument[15]} />\n        <NumberProperty size={4} label=\"Delay\" hint=\"Overlap with itself for reverb and flanger effects (seconds)\" min=\"0\" max=\"1000000000\" step=\"0.01\" on:input={handleChange} bind:value={instrument[16]} />\n        <NumberProperty size={4} label=\"Sustain Volume\" hint=\"Volume level for sustain (percent)\" min=\"0\" max=\"1000000000\" step=\"0.01\" on:input={handleChange} bind:value={instrument[17]} />\n        <NumberProperty size={4} label=\"Decay\" hint=\"Decay time, how long to reach sustain after attack\" min=\"0\" max=\"1\" step=\"0.01\" on:input={handleChange} bind:value={instrument[18]} />\n        <NumberProperty size={4} label=\"Tremolo\" hint=\"Trembling effect, rate controlled by repeat time (precent)\" min=\"0\" max=\"1\" step=\"0.01\" on:input={handleChange} bind:value={instrument[19]} />\n        <div class=\"outset\"></div>\n        <div class=\"outset\"></div>\n      </div>\n      <div class=\"instrument__preview outset\">\n        <SampleViewer data={buffer} />\n      </div>\n    </div>\n  </Pane>\n</div>\n\n<Modal title=\"Select an instrument\" bind:open={showInstrumentPicker}>\n  <InstrumentPicker on:apply={handleInstrumentApply} />\n</Modal>\n\n<style>\n.instrument {\n  display: flex;\n}\n\n.instrument__params {\n  display: grid;\n  grid-template-columns: repeat(3, 14em);\n}\n\n.instrument__preview {\n  flex: 1;\n}\n\n.usage {\n  min-width: 8em;\n  max-width: 17em;\n  overflow: auto;\n}\n</style>","<script>\n  export let id = null;\n  export let step = 1;\n  export let min = 0;\n  export let max = 1;\n  export let list = null;\n  export let value;\n</script>\n\n<input type=\"range\" {id} {step} {min} {max} {list} bind:value>\n\n<style>\n  input {\n    display: block;\n    margin: 0;\n    width: 100%;\n    padding: 4px;\n    height: 21px;\n    background-color: transparent;\n    -webkit-appearance: none;\n  }\n  input:focus {\n    outline: none;\n  }\n  input::-webkit-slider-runnable-track {\n    background: #777;\n    box-shadow: inset -1px -1px 0 #fff8, inset 1px 1px 0 #0003;\n    height: 6px;\n  }\n  input::-moz-range-track {\n    background: #777;\n    box-shadow: inset -1px -1px 0 #fff8, inset 1px 1px 0 #0003;\n    height: 6px;\n  }\n  input::-webkit-slider-thumb {\n    margin-top: -6px;\n    width: 30px;\n    height: 17px;\n    background: linear-gradient(90deg,#555 13px,  #87e6eb 15px,  #555 17px);\n    box-shadow: -1px -1px 0 #fff4, inset -1px -1px 0 #0004, 0px 1px 4px #000c;\n    -webkit-appearance: none;\n  }\n  input::-moz-range-thumb {\n    width: 30px;\n    height: 17px;\n    border: none;\n    border-radius: 0;\n    background: linear-gradient(90deg,#555 13px,  #87e6eb 15px,  #555 17px);\n    box-shadow: -1px -1px 0 #fff4, inset -1px -1px 0 #0004, 0px 1px 4px #000c;\n  }\n</style>","<script>\nimport Slider from './Slider.svelte';\n\nexport let value = 0;\n</script>\n\n<div>\n  <Slider step={.1} min={-1} max={1} list=\"stops\" bind:value />\n  <datalist id=\"stops\">\n    <option value=\"-1\" label=\"L\">\n    <option value=\"0\" label=\"C\">\n    <option value=\"1\" label=\"R\">\n  </datalist>\n</div>\n\n<style>\n  datalist {\n    display: flex;\n    justify-content: space-between;\n    padding: 0 14px;\n  }\n  option {\n    font-size: 80%;\n    padding:0 2px\n  }\n</style>\n","<script>\nimport { instrumentsMeta } from '../stores.js';\nimport { getNoteName } from '../services/PatternService.js';\nimport { clamp } from '../lib/utils.js';\nimport PanningProperty from './PanningProperty.svelte';\nimport Toolbar from './Toolbar.svelte';\nimport Field from './Field.svelte';\n\nexport let data = [];\nexport let title = 'Track';\nexport let selectedRow = 0;\nexport let mute = false;\n\n$: scrollPos = `${-selectedRow * 18}px`;\n$: totalRows = data.length - 3;\n\nlet scrollSpeed = 0;\n\nconst formatNote = note => {\n  const noteName = getNoteName([1 + note | 0]);\n  const attenuationValue = (note % 1) * 100;\n  if (attenuationValue === 0) {\n    return `${noteName} --`;\n  }\n  return `${noteName} ${attenuationValue.toFixed().padStart(2, '0')}`;\n};\n\nconst handleScroll = event => {\n  const {deltaY, deltaMode} = event;\n  if (deltaMode === 0) {\n    const step = deltaY / 4 | 0;\n    selectedRow = clamp(selectedRow + step, 0, totalRows);\n  }\n}\n\nconst decelerate = () => {\n  if (Math.abs(scrollSpeed)>.2) {\n    requestAnimationFrame(decelerate);\n    selectedRow += scrollSpeed / 4 | 0;\n    scrollSpeed *= .85;\n  } else {\n    scrollSpeed = 0;\n  }\n}\n\nconst handleTouchStart = event => {\n  if (event.targetTouches.length > 1) {\n    return;\n  }\n  const startPos = event.targetTouches[0].screenY;\n  const startRow = selectedRow;\n  let prevPos = startPos;\n  scrollSpeed = 0;\n\n  const moveHandler = event => {\n    const pos = event.targetTouches[0].screenY;\n    const step = (pos - startPos) / 18 | 0;\n    scrollSpeed = prevPos - pos;\n    selectedRow = clamp(startRow - step, 0, totalRows);\n    prevPos = pos;\n  }\n\n  const endHandler = event => {\n    if (Math.abs(prevPos - startPos) < 5) {\n      event.target.focus();\n    } else if (Math.abs(scrollSpeed) > .1) {\n      decelerate();\n    }\n    window.removeEventListener('touchmove', moveHandler);\n    window.removeEventListener('touchend', endHandler);\n  }\n\n  window.addEventListener('touchmove',moveHandler )\n  window.addEventListener('touchend',endHandler )\n}\n</script>\n\n<div class:mute class=\"channel\">\n  <Toolbar>\n    <Field label={title}>\n      <select class=\"select\" bind:value={data[0]}>\n        {#each $instrumentsMeta as name, i}\n          <option value={i}>{name}</option>\n        {/each}\n      </select>\n    </Field>\n  </Toolbar>\n\n  <div class=\"noteList\" tabindex=\"0\" on:wheel={handleScroll} on:touchstart|preventDefault={handleTouchStart}>\n    <pre class=\"notes\" style=\"transform:translateY({scrollPos})\">{data.slice(2).map(formatNote).join('\\n')}</pre>\n  </div>\n\n  <div class=\"outset\">\n    <PanningProperty bind:value={data[1]} />\n  </div>\n\n</div>\n\n<style>\n.select {\n  width: 100%;\n}\n.channel {\n  display: grid;\n  grid-template-rows: auto 1fr auto;\n  height: 100%;\n  width: 100%;\n}\n.noteList {\n  overflow: hidden;\n  position: relative;\n  background-image: linear-gradient(#fff 0, #fff 18px);\n  background-size:100% 18px;\n  background-repeat: no-repeat;\n  background-position: 0 50%;\n  text-align: center;\n  text-align-last: justify;\n  line-height:18px;\n  width:100%;\n  box-sizing:border-box;\n  box-shadow: inset 0 0 2px 0 #0008;\n}\n.notes {\n  pointer-events: none;\n  position: absolute;\n  top: 50%;\n  margin: -8px 0 0 0;\n  width:100%;\n  min-width:0;\n  padding:0 1em;\n  background-image: linear-gradient( #0001 18px, transparent 18px);\n  background-size:100% 72px;\n  white-space: pre-line;\n  will-change: transform;\n  word-spacing: 4em;\n}\n.channel :global(.field) {\n  align-items: center!important;\n}\n.channel :global(.field__controls) {\n  width: 100% !important;\n}\n.mute {\n  background:repeating-linear-gradient(45deg, #0001 0, #0001 5px,#0000 5px, #0000 10px);\n}\n</style>\n","<script>\nimport { NOTE_KEY_CODES } from '../config.js';\n\n$: keys = Object.entries(NOTE_KEY_CODES).sort((a,b) => a[1] - b[1]).map(([x]) => x);\n\nconst handleClick = event => {\n  const { target, button } = event;\n  if (button === 0) {\n    target.focus()\n    const event = new KeyboardEvent('keydown', {\n      key: target.dataset.note\n    });\n    window.dispatchEvent(event);\n  }\n};\n</script>\n\n<div>\n  {#each keys as key}\n    <span tabindex=\"0\" data-note={key} on:mousedown={handleClick}>\n      {key.toUpperCase()}\n    </span>\n  {/each}\n</div>\n\n<style>\n  div {\n    display: flex;\n    align-items: flex-start;\n    padding: var(--modal-spacing);\n  }\n  span {\n    padding-top: 76px;\n    padding-bottom: 4px;\n    background-color: #eee;\n    color:#888;\n    border-bottom-left-radius: 4px;\n    border-bottom-right-radius: 4px;\n    text-align: center;\n    box-shadow: 0 0 0px 1px #0006;\n    flex: 1;\n  }\n  span:nth-child(12n+2),\n  span:nth-child(12n+4),\n  span:nth-child(12n+7),\n  span:nth-child(12n+9),\n  span:nth-child(12n+11) {\n    background-color: #222;\n    padding-top: 40px;\n    margin: 0 -11px;\n    flex: .75;\n    z-index: 1;\n    box-shadow: 1px 1px 1px 1px #0006;\n    margin: 0 -1.75%;\n  }\n  span:hover {\n    filter:contrast(.7)\n  }\n  span + span {\n    margin-left: 1px;\n  }\n</style>\n","<script>\nimport { patterns, sequence, channelMeters, patternsMeta, songPlaying, patternMuteStates } from '../stores.js';\nimport { addPattern, deletePattern, addChannel, deleteChannel, addRow, deleteRow, createTrack, createPattern, clearRow, setPatternData } from '../services/PatternService.js';\nimport { playPattern, stopSong } from '../services/RendererService.js';\nimport { createEventDispatcher } from 'svelte';\nimport { clamp, deepClone } from '../lib/utils.js';\nimport Channel from './Channel.svelte';\nimport Pane from './Pane.svelte';\nimport Toolbar from './Toolbar.svelte';\nimport Field from './Field.svelte';\nimport Button from './Button.svelte';\nimport TextProperty from './TextProperty.svelte';\nimport NumberProperty from './NumberProperty.svelte';\nimport PianoInput from './PianoInput.svelte';\nimport ToggleButton from './ToggleButton.svelte';\nimport PlayButton from './PlayButton.svelte';\n\nexport let selectedChannel = 0;\nexport let selectedRow = 0;\nexport let selectedPattern = 0;\nexport let piano = false;\n\nlet channelClipboard;\nlet patternClipboard;\n\n$: patternCount = $patterns.length;\n$: channelCount = $patterns[selectedPattern].length;\n$: selectedPattern = clamp(selectedPattern, 0, $patterns.length - 1);\n$: selectedChannel = clamp(selectedChannel, 0, $patterns[selectedPattern].length - 1);\n$: selectedRow = clamp(selectedRow, 0, $patterns[selectedPattern][0].length - 3) | 0;\n\n\n$: usage = $sequence.map((pattern, i) => {\n  return pattern === selectedPattern && i\n}).filter(x => x !== false);\n\n\nconst dispatch = createEventDispatcher();\n\nconst channelElems = [];\n\n\nconst handleAddPatternClick = () => {\n  selectedPattern = addPattern(createPattern(3, 64));\n}\n\nconst handleDeletePatternClick = () => {\n  deletePattern(selectedPattern);\n}\n\nconst handleAddRowClick = () => {\n  selectedRow = addRow(selectedPattern);\n}\n\nconst handleDeleteRowClick = () => {\n  deleteRow(selectedPattern, selectedRow);\n}\n\nconst handleClearRowClick = () => {\n  clearRow(selectedPattern, selectedRow);\n}\n\nconst moveChannelLeft = () => {\n  swapChannels(selectedChannel, --selectedChannel);\n}\n\nconst moveChannelRight = () => {\n  swapChannels(selectedChannel, ++selectedChannel);\n}\n\nconst handleAddChannelClick = () => {\n  selectedChannel = addChannel(selectedPattern);\n}\n\nconst deleteChannelClick = () => {\n  deleteChannel(selectedPattern, selectedChannel);\n}\n\nconst clearChannel = () => {\n  $patterns[selectedPattern][selectedChannel].fill(0, 2);\n  $patterns[selectedPattern] = $patterns[selectedPattern];\n}\n\nconst swapChannels = (a, b) => {\n  const channels = $patterns[selectedPattern].slice();\n  [channels[a], channels[b]] = [channels[b], channels[a]];\n  $patterns[selectedPattern] = channels;\n}\n\nconst copyChannel = () => {\n  channelClipboard = $patterns[selectedPattern][selectedChannel].slice();\n}\n\nconst pasteChannel = () => {\n  const channelData = $patterns[selectedPattern][selectedChannel];\n  const clipboardData = channelClipboard.slice();\n  $patterns[selectedPattern][selectedChannel] = [\n    ...clipboardData.slice(0,channelData.length),\n    ...channelData.slice(clipboardData.length)\n  ];\n  $patterns[selectedPattern] = $patterns[selectedPattern];\n}\n\nconst handleCopyPatternClick = () => {\n  patternClipboard = deepClone($patterns[selectedPattern]);\n}\n\nconst handlePastePatternClick = () => {\n  setPatternData(selectedPattern, deepClone(patternClipboard));\n}\n\nconst handlePatternChange = () => {\n  dispatch('patternselect');\n  selectedRow = 0;\n}\n\nconst togglePlayPatternClick = () => {\n  if ($songPlaying) {\n    stopSong()\n  } else {\n    playPattern(selectedPattern);\n  }\n}\n\nconst handleUnmuteAllClick = () => {\n  $patternMuteStates[selectedPattern] = new Array(channelCount).fill(false);;\n}\n\nconst handleSoloClick = () => {\n  const muteState = new Array(channelCount).fill(true);\n  muteState[selectedChannel] = false;\n  $patternMuteStates[selectedPattern] = muteState;\n}\n\nconst handleMuteToggleClick = () => {\n  $patternMuteStates[selectedPattern][selectedChannel] = !$patternMuteStates[selectedPattern][selectedChannel]\n}\n</script>\n\n\n<div class=\"splitView\">\n  <Pane>\n    <div slot=\"head\">\n      <Toolbar>\n        <Field label=\"Patterns\">\n          <Button label=\"Add\" on:click={handleAddPatternClick} />\n          <Button label=\"Delete\" disabled={usage.length} on:click={handleDeletePatternClick} />\n          <Button label=\"Copy\" on:click={handleCopyPatternClick} />\n          <Button label=\"Paste\" disabled={!patternClipboard} on:click={handlePastePatternClick} />\n        </Field>\n      </Toolbar>\n    </div>\n    <select class=\"select\" on:input={handlePatternChange} bind:value={selectedPattern} size=\"2\">\n      {#each $patterns as pattern, i}\n        <option value={i}>{i}: {$patternMuteStates[i].includes(true) ? '[M]':''} {$patternsMeta[i]}</option>\n      {/each}\n    </select>\n  </Pane>\n\n  <Pane>\n    <div slot=\"head\">\n      <Toolbar>\n        <NumberProperty label=\"#\" max={patternCount} bind:value={selectedPattern} on:input={handlePatternChange}></NumberProperty>\n        <TextProperty label=\"Name\" bind:value={$patternsMeta[selectedPattern]}></TextProperty>\n        <Field label=\"Playback\">\n          <PlayButton playing={$songPlaying} keyboard=\"ENTER\" on:click={togglePlayPatternClick} />\n        </Field>\n        <Field label=\"Track\">\n          <Button on:click={handleAddChannelClick} label=\"Add\" />\n          <Button disabled={channelCount === 1} on:click={deleteChannelClick} label=\"Delete\" />\n          <Button on:click={clearChannel} label=\"Clear\" />\n          <Button on:click={copyChannel} label=\"Copy\" />\n          <Button disabled={!channelClipboard} on:click={pasteChannel} label=\"Paste\" />\n          <Button disabled={channelCount === 1 || selectedChannel === 0} on:click={moveChannelLeft} label=\"Move Left\" />\n          <Button disabled={channelCount === 1 || selectedChannel === channelCount - 1} on:click={moveChannelRight} label=\"Move Right\" />\n        </Field>\n        <Field label=\"Track Mute\">\n          <ToggleButton bind:checked={$patternMuteStates[selectedPattern][selectedChannel]} on:click={handleMuteToggleClick} label=\"Mute\" />\n          <Button on:click={handleSoloClick} label=\"Solo\" />\n          <Button on:click={handleUnmuteAllClick} label=\"Unmute All\" />\n        </Field>\n        <Field label=\"Row\">\n          <Button on:click={handleAddRowClick} label=\"Add\" />\n          <Button disabled={channelCount === 1} on:click={handleDeleteRowClick} label=\"Delete\" />\n          <Button label=\"Clear\" on:click={handleClearRowClick} />\n        </Field>\n        <div class=\"outset\"></div>\n      </Toolbar>\n    </div>\n    <div class=\"channels outset\">\n      {#each $patterns[selectedPattern] as channel, i}\n        <div class=\"channel inset\" bind:this={channelElems[i]} on:focusin={()=>selectedChannel = i} class:selected={i==selectedChannel}>\n          <Channel on:rowselect bind:mute={$patternMuteStates[selectedPattern][i]} title={`Track ${i}`} bind:selectedRow={selectedRow} bind:data={channel}></Channel>\n          <div class=\"level\" style=\"transform:scaleY({$channelMeters[i] || 0})\"></div>\n        </div>\n      {/each}\n    </div>\n    {#if piano}\n      <PianoInput />\n    {/if}\n  </Pane>\n</div>\n\n<style>\n  select {\n    display: block;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n  }\n  .selected {\n    background: var(--active-selection-color);\n  }\n  .channels {\n    display: grid;\n    grid-auto-flow: column;\n    grid-auto-columns: minmax(120px, 1fr);\n    overflow: auto;\n    gap: 10px;\n    padding: 10px\n  }\n  .channel {\n    position:relative;\n  }\n  .level {\n    position: absolute;\n    width: 32px;\n    background: linear-gradient(#fc0, #0c0);\n    bottom: 50%;\n    left: calc(50% - 16px);\n    height: 150px;\n    transform-origin: 50% 100%;\n    will-change: transform;\n  }\n</style>\n","<script>\n  import { PATTERN_ROW_COARSE_STEP } from '../config.js';\n\n\n  const isMac = navigator.userAgent.indexOf('Mac OS X') > -1;\n\n  const SHIFT_KEY = '⇧';\n  const ALT_KEY = isMac ? '⌥' : 'ALT';\n  const UP_KEY = isMac ? '▲' : 'ꜛ';\n  const DOWN_KEY = isMac ? '▼' : 'ꜜ';\n  const SPACE_KEY = 'SPACE';\n  const BACKSPACE_KEY = '←'\n  const keymap = [\n    {\n      name: 'Playback',\n      shortcuts: [\n        { keys: ['ENTER'], desc: 'Play / Stop the current pattern' },\n        { keys: [ALT_KEY, 'ENTER'], desc: 'Play / Stop song' },\n        { keys: [SHIFT_KEY, 'ENTER'], desc: 'Play the current pattern from the beginning' },\n        { keys: [ALT_KEY, SHIFT_KEY, 'ENTER'], desc: 'Play song from the beginning' },\n      ]\n    },\n    {\n      name: 'Editing',\n      shortcuts: [\n        { keys: [UP_KEY], desc: 'Move up one row in the pattern' },\n        { keys: [DOWN_KEY], desc: 'Move down one row in the pattern' },\n        { keys: [SHIFT_KEY, UP_KEY], desc: `Move up ${PATTERN_ROW_COARSE_STEP} rows in the pattern` },\n        { keys: [SHIFT_KEY, DOWN_KEY], desc: `Move down ${PATTERN_ROW_COARSE_STEP} rows in the pattern` },\n        { keys: [ALT_KEY, UP_KEY], desc: 'Increase note attenuation (fine)' },\n        { keys: [ALT_KEY, DOWN_KEY], desc: 'Decrease note attenuation (fine)' },\n        { keys: [ALT_KEY, SHIFT_KEY, UP_KEY], desc: 'Increase note attenuation (coarse)' },\n        { keys: [ALT_KEY, SHIFT_KEY, DOWN_KEY], desc: 'Decrease note attenuation (coarse)' },\n        { keys: [SPACE_KEY], desc: 'Release note'},\n        { keys: [BACKSPACE_KEY], desc: 'Clear note'}\n\n      ]\n    }\n  ];\n\n</script>\n\n{#each keymap as group}\n  {group.name}\n  <dl>\n    {#each group.shortcuts as shortcut}\n      <dt>\n        {#each shortcut.keys as key, i}\n          {#if i}&nbsp;+&nbsp;{/if}<kbd>{key}</kbd>\n        {/each}\n      </dt>\n      <dd>{shortcut.desc}</dd>\n    {/each}\n  </dl>\n{/each}\n\n\n<style>\n  kbd {\n    padding: 2px 4px;\n    background: #fff;\n    box-shadow: 0 1px 0px 1px #888;\n    border-radius: 2px;\n    letter-spacing: 0;\n    font: 12px / 1.25 Arial;\n  }\n  dl {\n    display: grid;\n    grid-template-columns: 15em auto;\n    gap: var(--modal-spacing);\n  }\n  dt {\n    word-spacing: -0.25em;\n    width: auto;\n    color: #444;\n  }\n  dd {\n    margin:0;\n  }\n</style>","<script>\n  import { version, repository } from '../../package.json';\n</script>\n\n<div>\n  <h1>ZzFXM Music Tracker</h1>\n  v{ version }\n  <p>by <a href=\"https://keithclark.co.uk\">Keith Clark</a></p>\n  <p>Source available at the <a target=\"_blank\" href=\"{repository.url}/tree/master/tools/tracker\">ZzFXM GitHub Repo</a></p>\n</div>\n\n<style>\ndiv {\n  text-align: center;\n}\nh1 {\n  font-size: 250%;\n  letter-spacing: -0.06em;\n  color: rgb(255,85,18);\n  animation: 10s colorshock linear infinite;\n  filter: drop-shadow(1px 1px 0px #0004) hue-rotate(0);\n}\n@keyframes colorshock {\n  from {\n    filter: drop-shadow(1px 1px 0px #0004) hue-rotate(360deg);\n  }\n}\n@supports (background-clip: text) {\n  h1 {\n    background: linear-gradient(135deg, rgb(255,85,18), rgb(247,255,15) 25%, rgb(5,193,255) 50%, rgb(171,69,255) 75%, rgb(255,85,18));\n    background-size: 2000px 2em;\n    background-repeat: repeat-x;\n    background-clip: text;\n    color: transparent;\n  }\n  @keyframes colorshock {\n    from {\n      background-position: 2000px 0;\n    }\n  }\n}\n</style>","<script>\n  import Button from './Button.svelte';\n  import { serializeSong, loadSongFromString } from '../services/SongService.js';\n  import { createEventDispatcher, onMount } from 'svelte';\n\n  let src;\n  let error;\n\n  const dispatch = createEventDispatcher()\n\n  onMount(()=> {\n    src = serializeSong();\n    error = null;\n  });\n\n  const applyClick = () => {\n    try {\n      loadSongFromString(src);\n      dispatch('apply');\n    } catch (e) {\n      error = e.message;\n    }\n  }\n</script>\n\n<div class=\"wrap\">\n  <div class=\"inset\">\n    <textarea class=\"inset input\" bind:value={src}></textarea>\n  </div>\n  {#if error}\n    <span>Error: {error}</span>\n  {/if}\n  <span>\n    <Button label=\"Apply\" on:click={applyClick} />\n  </span>\n</div>\n\n\n<style>\n.wrap {\n  display: grid;\n  grid-template-rows: 1fr auto;\n  gap: var(--panel-spacing);\n}\n.inset {\n  flex:1;\n}\ntextarea {\n  width: 100%;\n  height: 100%;\n  min-height:20em;\n  white-space: pre-line;\n  word-break: break-all;\n  resize: none;\n  display: block;\n}\n</style>\n","<script>\n  export let label = '';\n</script>\n\n<div class=\"propertyList\">\n  <div class=\"propertyList__label\">{ label }</div>\n  <div class=\"propertyList__properties inset\">\n    <slot />\n  </div>\n</div>\n\n<style>\n  .propertyList + .propertyList {\n    margin-top: var(--panel-spacing)\n  }\n  .propertyList__label {\n    padding: var(--field-padding);\n  }\n</style>","<script>\n  import Property from './Property.svelte';\n  export let label = '';\n  export let value = '';\n  export let options = [];\n  export let hint = '';\n</script>\n\n<Property {label} {hint} let:id={id}>\n  <select {id} class=\"select\" bind:value={value}>\n    {#each options as option}\n      <option>{option}</option>\n    {/each}\n  </select>\n</Property>\n","<script>\n  import {\n    PLAYER_BUFFER_SIZE_OPTIONS,\n    PLAYER_SAMPLE_RATE_OPTIONS,\n    UI_FPS_OPTIONS\n  } from '../config.js';\n  import { bufferSize, sampleRate, uiFPS } from '../stores.js';\n  import PropertyList from './PropertyList.svelte';\n  import EnumProperty from './EnumProperty.svelte';\n</script>\n\n\n<PropertyList label=\"Playback Settings\">\n  <EnumProperty hint=\"The amount of data the player will prerender before playing it. Increase this if your browser is cutting off audio during playback\" label=\"Playback buffer size (bytes)\" bind:value={$bufferSize} options={PLAYER_BUFFER_SIZE_OPTIONS} />\n  <EnumProperty hint=\"Controls the audio quality. Reduce in favour of UI responsiveness if your browser is consuming too many system resources\" label=\"Playback sample rate (hz)\" bind:value={$sampleRate} options={PLAYER_SAMPLE_RATE_OPTIONS} />\n  <EnumProperty hint=\"Controls the responsiveness of the UI during playback. Reduce in favour of audio quality if your browser is consuming too many system resources\" label=\"UI Refresh rate (FPS)\" bind:value={$uiFPS} options={UI_FPS_OPTIONS} />\n</PropertyList>\n","<script>\n  import { currentPlaybackLength, speed, title, meta } from '../stores';\n  import { serializeSong } from '../services/SongService.js';\n  import { onMount } from 'svelte';\n\n  import PropertyList from './PropertyList.svelte';\n  import Property from './Property.svelte';\n  import TextProperty from './TextProperty.svelte';\n\n  let duration = '?';\n  let size = '?';\n  let gzipSize = '?';\n  let timer;\n\n  const updateSize = () => {\n    size = serializeSong().length;\n  }\n\n  onMount(() => {\n    duration = Math.floor($currentPlaybackLength * (125 / $speed) / 8.47);\n    updateSize();\n    if ('pako' in window) {\n      gzipSize = pako.deflate(serializeSong({noMeta: true})).length;\n    }\n  });\n\n  $: if ($title || $meta) {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(updateSize, 1000);\n  }\n</script>\n\n\n<PropertyList label=\"Metadata\">\n  <TextProperty size={40} hint=\"The name of the song\" label=\"Title\" bind:value={$title} />\n  <TextProperty size={40} hint=\"The name of the composer\" label=\"Author\" bind:value={$meta.author} />\n  <TextProperty size={40} hint=\"The URL of the composer\" label=\"Author URL\" bind:value={$meta.authorUrl} />\n  <TextProperty size={40} hint=\"Notes about the song\" label=\"Notes\" bind:value={$meta.notes} multiline />\n  <TextProperty size={4} hint=\"The license of the song\" label=\"License\" bind:value={$meta.license} />\n</PropertyList>\n<PropertyList label=\"Properties\">\n  <Property label=\"Playback time\"><span class=\"output\">{duration} seconds</span></Property>\n  <Property label=\"Raw file size\"><span class=\"output\">{size} bytes</span></Property>\n  <Property label=\"Deflated file size (no meta data)\"><span class=\"output\">{gzipSize} bytes</span></Property>\n</PropertyList>\n","<script>\n\n  import { patterns, sequence, speed, title, selectedRow, selectedChannel, selectedPattern, selectedSequence, selectedInstrument, masterVolume, currentPlaybackPosition, songPlaying } from './stores.js';\n  import { serializeSong, createEmptySong, loadSongFromFile, loadSongFromUrl } from './services/SongService.js';\n  import { playPattern, playSong, stopSong, playNote } from './services/RendererService.js';\n  import { getCumlativeRowAtPosition } from './services/SequenceService.js';\n  import { adjustAttenuation, setNote } from './services/PatternService.js';\n  import { isInputElement } from './lib/utils.js';\n  import { NOTE_KEY_CODES, PATTERN_ROW_FINE_STEP, PATTERN_ROW_COARSE_STEP, ATTENUATION_FINE_STEP, ATTENUATION_COARSE_STEP} from './config.js';\n\n  import SequenceEditor from './components/SequenceEditor.svelte';\n\timport InstrumentEditor from './components/InstrumentEditor.svelte';\n\timport PatternEditor from './components/PatternEditor.svelte';\n  import TextProperty from './components/TextProperty.svelte';\n  import NumberProperty from './components/NumberProperty.svelte';\n  import Property from './components/Property.svelte'\n  import Toolbar from './components/Toolbar.svelte';\n  import Field from './components/Field.svelte';\n  import Button from './components/Button.svelte';\n\n  import ToggleButton from './components/ToggleButton.svelte';\n  import Slider from './components/Slider.svelte';\n  import Pane from './components/Pane.svelte';\n  import Modal from './components/Modal.svelte';\n  import KeyboardHelp from './components/KeyboardHelp.svelte';\n  import About from './components/About.svelte';\n  import SourceEditor from './components/SourceEditor.svelte';\n  import Preferences from './components/Preferences.svelte';\n  import SongProperties from './components/SongProperties.svelte';\n\n  let files;\n  let fileElem;\n  let showKeysHelpModal = false;\n  let showAboutModal = false;\n  let showSourceModal = false;\n  let showSettingsModal = false;\n  let showSongPropertiesModal = false;\n  let showPaino = window.matchMedia('(min-height: 500px)').matches;\n  let showInstruments = window.matchMedia('(min-height: 800px)').matches;\n\n  $: if (files) {\n    loadSong(loadSongFromFile, files[0]);\n    files = null;\n  }\n\n  $: patternStartPosition = getCumlativeRowAtPosition($selectedSequence);\n  $: patternPosition = patternStartPosition + $selectedRow;\n  $: if ($selectedSequence !== null) {\n    currentPlaybackPosition.set(patternPosition);\n  } else {\n    currentPlaybackPosition.set(-1);\n  }\n\n  const loadSong = (loader, src) => {\n    stopSong();\n    return loader(src)\n      .then(resetSongPosition)\n      .catch(err => alert(`Error loading ${src}\\n\\n${err.message}`));\n  }\n\n\n  const resetSongPosition = () => {\n    selectedSequence.set(0);\n    selectedPattern.set($sequence[0]);\n    selectedRow.set(0);\n  }\n\n  const resetPatternPosition = () => {\n    selectedRow.set(0);\n  }\n\n  const handlePatternSelect = () => {\n    stopSong();\n    currentPlaybackPosition.set(-1);\n    selectedSequence.set(null);\n  }\n\n  const handlePositionChange = () => {\n    selectedPattern.set($sequence[$selectedSequence]);\n  }\n\n  const handlePositionSelect = () => {\n    stopSong();\n    selectedPattern.set($sequence[$selectedSequence]);\n    selectedRow.set(0);\n  }\n\n  const handleLoadSongClick = () => {\n    fileElem.click();\n  }\n\n  const handleSaveSongClick = () => {\n    const element = document.createElement('a');\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(serializeSong()));\n    element.setAttribute('download', `${$title}.js`);\n    element.style.display = 'none';\n    document.body.appendChild(element);\n    element.click();\n    element.remove();\n  }\n\n  const handleHelpClick = () => {\n    showKeysHelpModal = true;\n  }\n\n  const handleAboutClick = () => {\n    showAboutModal = true;\n  }\n\n  const handleKeyPress = event => {\n    const { key, shiftKey, altKey, ctrlKey, metaKey } = event;\n\n    // If the active element is a form input (button, input etc.) do nothing\n    if (isInputElement(document.activeElement)) {\n      return;\n    }\n\n    if (key === 'ArrowLeft') {\n      $selectedChannel--;\n    } else if (key === 'ArrowRight') {\n      $selectedChannel++;\n    } else if (key === 'ArrowUp') {\n      if (altKey) {\n        const step = shiftKey ? ATTENUATION_COARSE_STEP : ATTENUATION_FINE_STEP;\n        adjustAttenuation($selectedPattern, $selectedChannel, $selectedRow, step);\n      } else {\n        const step = shiftKey ? PATTERN_ROW_COARSE_STEP : PATTERN_ROW_FINE_STEP;\n        $selectedRow = Math.max(0, $selectedRow - step);\n      }\n    } else if (key === 'ArrowDown') {\n      if (altKey) {\n        const step = shiftKey ? ATTENUATION_COARSE_STEP : ATTENUATION_FINE_STEP;\n        adjustAttenuation($selectedPattern, $selectedChannel, $selectedRow, -step)\n      } else {\n        const step = shiftKey ? PATTERN_ROW_COARSE_STEP : PATTERN_ROW_FINE_STEP;\n        $selectedRow = Math.min($patterns[$selectedPattern][0].length - 3, $selectedRow + step);\n      }\n    } else if (key === ' ') {\n      setNote($selectedPattern, $selectedChannel, $selectedRow, -1);\n    } else if (key === 'Backspace') {\n      event.preventDefault();\n      setNote($selectedPattern, $selectedChannel, $selectedRow, 0);\n    } else if (key === 'Enter') {\n      if ($songPlaying) {\n        stopSong();\n      } else {\n        if (altKey) {\n          if (shiftKey) {\n            resetSongPosition();\n          }\n          playSong();\n        } else {\n          if (shiftKey) {\n            resetPatternPosition();\n          }\n          playPattern($selectedPattern);\n        }\n      }\n      event.preventDefault();\n    } else if (!shiftKey && !altKey && !metaKey && !ctrlKey) {\n      const note = NOTE_KEY_CODES[key];\n      if (note) {\n        setNote($selectedPattern, $selectedChannel, $selectedRow, note);\n        playNote($patterns[$selectedPattern][$selectedChannel][0] || 0, note);\n      }\n    }\n  }\n\n  const handleNewSongClick = () => {\n    stopSong();\n    createEmptySong();\n    resetSongPosition();\n  }\n\n  const handleSourceClick = () => {\n    showSourceModal = true;\n  }\n\n  const handlePianoToggleClick = () => {\n    showPaino = !showPaino;\n  }\n\n  const handleInstrumentsToggleClick = () => {\n    showInstruments = !showInstruments;\n  }\n\n  const handleSettingsClick = () => {\n    showSettingsModal = !showSettingsModal;\n  }\n\n  const handleSongPropertiesClick = () => {\n    showSongPropertiesModal = !showSongPropertiesModal;\n  }\n\n  const params = new URLSearchParams(location.search);\n\n  createEmptySong();\n  if (params.has('url')) {\n    loadSong(loadSongFromUrl, params.get('url'));\n  }\n\n  $: if ($patterns[$selectedPattern][$selectedChannel]) {\n    selectedInstrument.set($patterns[$selectedPattern][$selectedChannel][0]);\n  }\n</script>\n\n<main>\n  <Pane>\n    <div slot=\"head\">\n      <Toolbar>\n        <TextProperty label=\"Title\" bind:value={$title} />\n        <NumberProperty label=\"Speed\" bind:value={$speed} size={3} min={1} max={320} />\n        <Field label=\"File\">\n          <Button label=\"New\" on:click={handleNewSongClick} />\n          <Button label=\"Load\" on:click={handleLoadSongClick} />\n          <Button label=\"Save\" on:click={handleSaveSongClick} />\n          <Button label=\"Source\" on:click={handleSourceClick} />\n          <Button label=\"Properties\" on:click={handleSongPropertiesClick} />\n        </Field>\n        <Field label=\"Toggle Tools\">\n          <ToggleButton checked={showPaino} on:click={handlePianoToggleClick} label=\"Piano\" />\n          <ToggleButton checked={showInstruments} on:click={handleInstrumentsToggleClick} label=\"Instruments\" />\n        </Field>\n        <Property label=\"Master Volume\" let:id>\n          <Slider {id} min={0} max={1} step={.1} bind:value={$masterVolume} />\n        </Property>\n        <Field label=\"Help\">\n          <Button label=\"Settings\" on:click={handleSettingsClick} />\n          <Button label=\"About\" on:click={handleAboutClick} />\n          <Button label=\"Keys\" on:click={handleHelpClick} />\n        </Field>\n\n        <div class=\"outset\"></div>\n      </Toolbar>\n    </div>\n  </Pane>\n\n  <SequenceEditor bind:selectedPosition={$selectedSequence} on:select={handlePositionSelect} on:input={handlePositionChange} />\n\n  <PatternEditor piano={showPaino} bind:selectedChannel={$selectedChannel} bind:selectedRow={$selectedRow} bind:selectedPattern={$selectedPattern} on:patternselect={handlePatternSelect} />\n\n  {#if showInstruments}\n    <InstrumentEditor selected={$selectedInstrument} />\n  {/if}\n</main>\n\n<Modal title=\"Source\" bind:open={showSourceModal}>\n  <SourceEditor on:apply={() => showSourceModal = false}/>\n</Modal>\n\n<Modal title=\"About\" bind:open={showAboutModal}>\n  <About />\n</Modal>\n\n<Modal title=\"Song Properties\" bind:open={showSongPropertiesModal}>\n  <SongProperties />\n</Modal>\n\n<Modal title=\"Settings\" bind:open={showSettingsModal}>\n  <Preferences />\n</Modal>\n\n<Modal title=\"Keyboard shortcuts\" bind:open={showKeysHelpModal}>\n  <KeyboardHelp />\n</Modal>\n\n<input type=\"file\" hidden bind:this={fileElem} bind:files>\n<svelte:window on:keydown={handleKeyPress} />\n\n<style>\n  main {\n    display: grid;\n    grid-template-rows: auto auto 1fr;\n    height: 100vh;\n    gap: var(--panel-spacing);\n    padding: var(--panel-spacing);\n    box-sizing: border-box;\n  }\n</style>\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body\n});\n\nexport default app;"],"names":["noop","identity","x","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","value","_","component_subscribe","component","callback","$$","on_destroy","push","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","tar","src","k","assign","slice","update_slot","slot","slot_definition","dirty","get_slot_changes_fn","get_slot_context_fn","slot_changes","lets","undefined","merged","len","Math","max","length","i","get_slot_changes","slot_context","p","set_store_value","ret","set","is_client","window","now","performance","Date","raf","cb","requestAnimationFrame","tasks","Set","run_tasks","task","c","delete","f","size","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","element","name","document","createElement","svg_element","createElementNS","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_input_value","input","set_style","key","important","style","setProperty","select_option","select","option","__value","selected","select_value","selected_option","querySelector","toggle_class","toggle","classList","custom_event","type","detail","e","createEvent","initCustomEvent","active_docs","current_component","active","create_rule","duration","delay","ease","uid","step","keyframes","t","rule","str","hash","charCodeAt","doc","ownerDocument","add","stylesheet","__svelte_stylesheet","head","sheet","current_rules","__svelte_rules","insertRule","cssRules","animation","delete_rule","previous","split","next","filter","anim","indexOf","deleted","join","deleteRule","clear","set_current_component","get_current_component","Error","onMount","on_mount","onDestroy","createEventDispatcher","call","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","schedule_update","then","flush","add_render_callback","add_flush_callback","flushing","seen_callbacks","update","pop","has","fragment","before_update","after_update","promise","dispatch","direction","kind","dispatchEvent","outroing","outros","group_outros","r","check_outros","transition_in","block","local","transition_out","o","null_transition","create_bidirectional_transition","params","intro","config","running_program","pending_program","animation_name","clear_animation","init","program","abs","start","end","group","go","easing","tick","css","fulfill","loop","[object Object]","globals","globalThis","global","destroy_block","lookup","bind","index","props","bound","create_component","mount_component","m","new_on_destroy","map","destroy_component","instance","create_fragment","not_equal","parent_component","prop_values","context","Map","skip_bound","ready","rest","fill","make_dirty","hydrate","nodes","Array","from","childNodes","children","l","SvelteComponent","this","$destroy","splice","$$props","obj","$$set","keys","NOTE_KEY_CODES","z","s","v","g","h","n","j",",",".",";","/","q","2","w","3","4","6","y","7","u","9","0","-","[","UI_FPS_OPTIONS","PLAYER_SAMPLE_RATE_OPTIONS","PLAYER_BUFFER_SIZE_OPTIONS","DEFAULT_PLAYER_SAMPLE_RATE","DEFAULT_PLAYER_BUFFER_SIZE","DEFAULT_UI_FPS","subscriber_queue","writable","stop","subscribers","new_value","run_queue","invalidate","subscriber","title","speed","instruments","instrumentsMeta","patterns","patternsMeta","sequence","meta","selectedRow","selectedChannel","selectedPattern","selectedSequence","selectedInstrument","masterVolume","currentPlaybackPosition","currentPlaybackLength","channelMeters","patternMuteStates","songPlaying","sampleRate","bufferSize","uiFPS","encodeInstruments","encodeInstrument","instrument","encoded","JSON","stringify","replace","encodeNumber","encodePatterns","encodeSequence","encodeSpeed","notNumber","isNumber","notArray","isArray","notObject","isObject","isNaN","parseFloat","is","constructor","validateSong","song","valid","some","flat","validateInstruments","validatePatterns","validateSequence","parse","jsonSafe","decodePatternParams","pattern","channel","decodeInstrumentParams","param","instrumentNo","addInstrument","newIndex","createInstrument","setInstrumentParams","clamp","min","round","decimalPlaces","pow","deepClone","NOTE_NAMES","patternNo","addPattern","states","createTrack","rows","panning","adjustAttenuation","row","channelRows","note","attenuation","setNote","currentAttenuation","getNoteName","noteId","getCumlativeRowAtPosition","sequencePos","patts","get","seq","sequenceIndex","getSongLength","clearSong","createEmptySong","setSong","serializeSong","tidyMeta","filtered","entries","fromEntries","removeEmptyStringValues","serializedMeta","noMeta","metaData","loadSongFromFile","file","url","URL","createObjectURL","loadSongFromUrl","finally","revokeObjectURL","fetch","res","loadSongFromString","songString","decodeSong","processor","insts","spd","playbackSequence","targetUpdateFps","currentSongPosition","songLength","currentBufferSize","mutedTracks","pos","currentOffset","channels","activeSoundCount","isPlaying","frames","gainNode","zzfxX","createGain","connect","destination","suspend","registerSound","async","resume","unregisterSound","initScriptProcessor","createScriptProcessor","onaudioprocess","audioCallback","killScriptProcessor","disconnect","getPositionInfo","position","nextPos","patternIndex","sample","renderNote","offset","mixChannelSampleData","leftChannelData","rightChannelData","peak","zzfxR","sampleLength","play","updateUI","setTimeout","peakLevels","shift","outputBuffer","dataL","getChannelData","dataR","bufferRemaining","beatLength","frameSize","beatDuration","channelIndex","instr","zzfxG","playNote","playSample","zzfxP","onended","playPattern","fromStart","playSong","stopSong","label","gain","hint","disabled","keyboard","playing","markerElem","scrollElem","observer","selectedPosition","userIsScrolling","handleUserScroll","IntersectionObserver","isIntersecting","scrollIntoView","behavior","inline","root","threshold","hasSelection","$songPlaying","observe","unobserve","$sequence","checked","globalId","warning","reason","id","multiline","fineStep","coarseStep","elem","lastGoodValue","validateValue","newValue","stopImmediatePropagation","shiftKey","canvas","canvasWidth","canvasHeight","debounce","resizeObserver","ResizeObserver","entry","width","height","contentRect","generateSampleView","parentElement","clientWidth","clientHeight","getContext","strokeStyle","beginPath","moveTo","lineTo","stroke","closePath","old_blocks","get_key","dynamic","list","destroy","create_each_block","get_context","old_indexes","new_blocks","new_lookup","deltas","child_ctx","will_move","did_move","first","new_block","old_block","new_key","old_key","format","substr","toUpperCase","percussion","keyboards","wind","items","selection","cubicOut","fade","linear","getComputedStyle","opacity","fly","target_opacity","transform","od","open","close","preventDefault","notelist","shapeOptions","clipboard","currentNote","showInstrumentPicker","playOnChange","testNote","waveformCache","WeakMap","getWave","recache","buffer","previewBuffer","playTestNote","$instruments","usage","$patterns","code","prompt","decodeInstrument","alert","$instrumentsMeta","mute","scrollSpeed","decelerate","scrollPos","totalRows","noteName","attenuationValue","toFixed","padStart","deltaY","deltaMode","targetTouches","startPos","screenY","startRow","prevPos","moveHandler","endHandler","focus","sort","button","KeyboardEvent","dataset","includes","channelClipboard","patternClipboard","piano","channelElems","swapChannels","patternCount","channelCount","tracks","createPattern","addRow","track","rowCount","addChannel","channelData","clipboardData","$patternMuteStates","muteState","$patternsMeta","desc","shortcuts","isMac","navigator","userAgent","ALT_KEY","UP_KEY","DOWN_KEY","repository","error","message","$bufferSize","$sampleRate","$uiFPS","author","authorUrl","notes","license","timer","gzipSize","updateSize","floor","$currentPlaybackLength","$speed","pako","deflate","$title","$meta","clearTimeout","files","fileElem","showKeysHelpModal","showAboutModal","showSourceModal","showSettingsModal","showSongPropertiesModal","showPaino","matchMedia","matches","showInstruments","loadSong","loader","resetSongPosition","catch","err","URLSearchParams","location","search","patternStartPosition","$selectedSequence","patternPosition","$selectedRow","$selectedPattern","$selectedChannel","click","encodeURIComponent","display","body","remove","altKey","ctrlKey","metaKey","isInputElement","activeElement","$masterVolume"],"mappings":"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"}